\section{Introduction}

Network operators of cloud datacenters deal with thousands of flow
groups traversing large number of heterogeneous devices. With growing
diversity of applications, need for security and compliance, and the
advent of cloud comouting, these flow groups may be subject to
increasingly complex policies.

Consider a tenant in such a data center. She may desire---in addition
to basic reachability among her hosts or applications---that
traffic attempting to reach some of her applications, or traffic from
certain other tenants, be examined by a set of middleboxes to ensure
access controls. Another tenant may additionally desire (a subset of)
her flows to be isolated from others' flows for strong security or QoS
reasons. On top of this, cloud operators may need to satisfy resource
constraints pertaining to link bandwidths and switch table sizes in
order to perform traffic engineering and network resource management.

Unfortunately, configuring network devices to implement these diverse
and complex policies in aggregate is manual, ad-hoc, and error prone
today. This can lead to mis-configurations and violations of tenant
service-level agreements which can have severe performance and
security impact.

%%  However, in real-life, the
%% process of policy enforcement by network operators is manual and
%% ad-hoc, leading to violations of service-level agreements and
%% mis-configurations which have severe performance and security
%% impacts. With the boom in cloud services, datacenter networks deal
%% with thousands of flows which are not constant, but in flux, thus,
%% making it difficult to enforce them in an ad-hoc manner.

%% Network operators desire various different end-to-end policies to
%% support in clouds and enterprise networks. Tenants or organisations
%% require support for basic policies like reachability between hosts,
%% and specifying different middlebox policies for certain
%% flows. Operators, on top of that require support for complex policies
%% like traffic isolation between flows to provide fairness and
%% specifying resource constraints like link bandwidth and switch table
%% sizes to perform traffic engineering and network resource management.

Though Software Defined Networking (SDN) has allowed network operators
to program networks in a more intuitive manner, many of existing SDN
tools/frameworks are too low-level for providing the needed
functionality. Writing controller applications that generate the
data plane to realize the above policies is challenging. %% For many
%% of the policies, generating the data plane is an NP-complete problem
%% and requires the design of efficient custom heuristics; combining
%% different policies' heuristics together is non-trivial.
For many of the
  policies, generating the data plane is an NP-complete problem and
  requires the design of efficient custom heuristics; combining
  different policies' heuristics together is non-trivial. Existing
languages like Frenetic~\cite{frenetic} and Pyretic~\cite{pyretic} are
too constraining: data center operators would ideally want to specify
and realize policies network-wide, whereas these languages focus on
programming individual switch behaviors. %% \aditya{we need to be
% careful
%%   not to bin all SDN languages into this switch-by-switch model}
%% \kausik{Do you want to make changes here?}
Other research on network-wide policy enforcement, e.g.,
Merlin~\cite{Merlin} and SIMPLE~\cite{simple}, are tailor-made to
specific sets of policies, and thus, difficult to extend to support
other kinds of policies. We review relevant work in
Section~\ref{s:related}.

%%  like
%% joint bandwidth provisioning and waypoint routing in Merlin
%% \cite{Merlin}, and middlebox policy enforcement in SIMPLE
%% \cite{simple} or FlowTags~\cite{flowtags}. However, these approaches

In this paper, we seek a {\em general} approach that allows a variety
of rich policies to be specified in a simple, declarative way, and the
complexities of correctly realizing the policies in the data plane are
hidden away from the data center operators. Such an approach would
pave the way for {\em intent-based networking}~\cite{}, where
operators and users specify {\em what} they want the network to do and
operators do not have to worry about {\em how} they would configure
their networks. %% To support a cornucopia of policies, an
%% important feature is \emph{generality} of the approach of policy
%% enforcement, so that it can be extended to enforce custom policies
%% required by the operator.
This paper makes a case for using \emph{synthesis} of switch table
forwarding rules as an effective and practical approach to realizing
this vision.
%% switch
%% table forwarding rules to the solve the problem of policy enforcement
%% by use of off-the-shelf SMT-solvers.

We present \Name, a framework for declaratively specifying and
enforcing complex policies.  We show that enforcement of several of
the policies supported by \Name, e.g., isolation and middlebox
traversal, is NP-complete. Thus, \Name, leverages recent advances in
fast Satisfiability Modulo Theories (SMT) solvers (e.g., Z3~\cite{z3})
to perform synthesis by encoding the problem of enforcing various
policies into a SMT instance, and using the SMT solver to search for a
solution. The solution is then translated into switch rules. %% This
%% paper presents Genesis, a
%% network management tool where the network operators can express the
%% network-wide policies in a high-level declarative manner and Genesis
%% will synthesize the lower-level switch forwarding rules for realising
%% these policies, eliminating the need for operators to work on
%% switch-level behaviours.
By leveraging the formal reasoning foundations of SAT/SMT solving,
\Name eliminates the room for error in the enforcement of even the
most complex collections of policies.

Unfortunately, naively encoding policies using SMT solvers results in
synthesis speeds that don't match the scale of operations of cloud and
enterprise networks today. \aditya{give an example as to how slow
  things can get} For instance, for synthesizing rules for simple
reachability among nodes in in a 125 switch fat-tree topology can take
1s,\aditya{why does this happen? talking about what causes poor
  performance so that the tactics idea later in this para makes sense}
thus needing a way to specify a search strategy for the path.  To this
end, \Name leverages domain-specific properties to simplify the
constraints handled by the SMT solver.  Specifically, \Name allows the
network operator to write regular expressions that blacklist certain
forwarding plane configurations \kausik{Shouldn't we mention paths
  here instead of configurations? } that are not desired in a data
center network structure.  \aditya{the previous sentence is vague}
By identifying a restricted syntax for specifying
tactics, we can improve the synthesis procedure by reducing the
constraints added to the solver without additional constraints
required to ensure the solution satisfies the tactic. \aditya{quickly
  talk about a highlight regarding the performance benefits of using
  tactics}

 Secondly, \Name can use a heuristical synthesis routine termed as
 \emph{optimistic} synthesis, that leverages the structure of tenants'
 isolation policy interactions to improve synthesis performance. The
 premise of this synthesis routine is to partition the input isolation
 policies into effective components and synthesize these components
 faster than the complete problem (due to the exponential time
 complexity). Across varying workloads, using optimistic synthesis can
 achieve a speed-up factor of greater than 2 for 40\% of the workloads
 and degraded performance for only 20\% of the workloads.  \aditya{the
   previous sentence is vague} 

%% are
%% huge, and by supporting a set of diverse and complex policies with
%% different search objectives, we require to create a model general and
%% expressive enough to support these. This poses a challenge as to can
%% synthesis performance be improved by leveraging knowledge specific to
%% the problem of policy enforcement in networks?

We implement \Name using ... We evaluate it using .... Key highlights .... \aditya{all of these are todo}.\kausik{Do we need a para or will the next para suffice?}

Thus, the main contribution of this paper are: 
\begin{itemize}
\item \Name, an extensible declarative language for describing complex policies that can
		handle new forms of policies such as isolation and unordered middlebox traversals.				
\item A modular SMT-based algorithm for enforcing \Name policies that can easily be extended
			to novel types of policies.
\item Tactics, a functionality for operators to specify blacklists on the properties of paths
 leveraging the hierarchical structure of datacenter topologies. 
 Tactics are specified using regular expressions using a restricted syntax which reduces the number of constraints.
\item An implementation of \Name and its enforcing algorithm using the SMT
		solver Z3 together with an extensive evaluation on different policy workloads and topology 
		sizes to quantify the performance of Genesis. 
\end{itemize}
\aditya{todo}

%% : We present the design and implementation of a network management
%% system with support for a diverse set of complex end-to-end
%% policies like isolation, waypoints and capacity. We designed a
%% novel search strategy using regular expressions to prune the space
%% of forwarding plane configurations by leveraging the network
%% structure to provide properties of the path, especially in
%% datacenter topologies. Lastly, we design a heuristical synthesis
%% routine leveraging the nature of policy interactions to improve
%% synthesis performance.
