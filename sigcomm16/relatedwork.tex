\section{Related Work}
\cite{decentralize} tries to synthesize local forwarding rules for a single switch based on a reactive forwarding policy. One of the important considerations for correctness of forwarding rules is that the controller sees all relevant events and rules are not added prematurely. The abstraction for expressing forwarding policies are for individual switches, on the other hand, we try to enforce network-wide policies, so each switch will have different forwarding policy such that the entire network enforces the flow policies. Also, the policies we deal with are proactive, so we need not worry about the controller seeing the relevant events (which is a requirement in synthesizing rules for reactive policies). For all practical purposes, we needn't worry about switch-controller interactions or premature rule installations. 

NetEgg \cite{netegg} synthesizes the forwarding policy of a switch using examples of how the switch should function when it receives packets. This deals with the forwarding policy of individual elements, can cannot be used directly to synthesize network-wide policies. 

\cite{oneswitch} tries to tackle a similar problem to ours of flow policy enforcement. However their end-point policies are only concerned with reachability (two hosts can talk through specific ingress and egress points). Their rule placement algorithm takes the path of the flow in the network as an input (the routing policy) and place rules on this path to enforce the endpoint policy and taking in consideration switch table constraints. We are trying to tackle the problem without the routing policy as input, as we enforce flow policies which would require different routing policies (like traffic isolation), so we cannot determine the path of the flow beforehand. Our solution can support enforcement of policies which require different routing policies. \cite{distfirewall} builts on the \cite{oneswitch} abstraction to optimize the specific case of distributed firewall policy enforcement using ILP.  

The closest approaches to ours are Merlin~\cite{merlin} and NetGen~\cite{netgen}.
In Merlin data plans that adhere to policies expressed using simple regular expressions are synthesized using linear integer constraints. 
Merlin also supports traffic engineering and load distribution thanks to the encoding in linear integer arithmetic. 
In NetGen network updates that adhere to policies expressed using regular expressions are synthesized using SMT solvers. 
Given a specification which mentions the packet classes, the old path and the new path, NetGen solves the network change problem using a SMT solver. 
While uninterpreted functions help reducing the number of constraints we found them to be slower than using SAT when combining with complex policies. 

Both Merlin and NetGen use specification languages that are based on regular expressions. 
While regular expressions provide a way to 
use elegant automata algorithms, they have the drawback of complicating the addition of new types of policies.
In particular, expressing a policy including a waypoint set $W$ of size $k$ would require a regular expression of size exponential
in $k$ as all the possible permutations of the elements of $W$.
Moreover, it is not clear how isolation constraints can be added to these frameworks.
% Write about PGA, NetGen, and efficient update synthesis.