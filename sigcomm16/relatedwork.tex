\section{Related Work} \label{sec:relatedwork}

\cite{oneswitch} tries to tackle a similar problem to ours of flow policy enforcement. However their end-point policies are only concerned with reachability (two hosts can talk through specific ingress and egress points). Their rule placement algorithm takes the path of the flow in the network as an input (the routing policy) and place rules on this path to enforce the endpoint policy and taking in consideration switch table constraints. We are trying to tackle the problem without the routing policy as input, as we enforce flow policies which would require different routing policies (like traffic isolation), so we cannot determine the path of the flow beforehand. Our solution can support enforcement of policies which require different routing policies. \cite{distfirewall} builts on the \cite{oneswitch} abstraction to optimize the specific case of distributed firewall policy enforcement using ILP.  PGA  \cite{pga} is a graph-level abstraction of 
specifying network policies like ACLs and middlebox service chaining. However, it abstracts the underlying network as "one bigswitch" and 
cannot be used to compose policies like tenant isolation or traffic engineering.  

\paragraph{Policy languages}
The closest approaches to ours are Merlin~\cite{merlin} and NetGen~\cite{netgen}.
In Merlin data plans that adhere to policies expressed using regular expressions are synthesized
by first intersecting the topology with the regular expressions appearing in the policies and then encoding reachability in the
intersected graph using mixed integer linear programming (ILP). 
Unlike \Name, Merlin also supports traffic engineering and load distribution.
Merlin's language does not support isolation policies, but we believe that it could be extended to support them. 
We cannot evaluate the performance impact of this extension.
A more prominent difference arises with unordered waypoint policies:
expressing a policy including a waypoint set $W$ of size $k$ require a regular expression of size exponential
in $k$ as all the possible permutations of the elements of $W$. This fact clearly impacts the performance of the Merlin's
compiler that would have to generate a mixed ILP with a large number of variables.
In \Name this is not the case as waypoint can be encoded with polynomially many constraints.
While this does not affect the theoretical complexity, our compiler does not incur into an a-priori exponential
blow-up and it rather relies on the power of SMT solvers to guide the search.
This is one of the main aspects behind our decision of not using regular expressions to express policies.
\Name uses a restricted form of regular expressions to introduce tactics that leverage the network topology.
While in Merlin regular expressions \emph{increase} the number of constraints generated by the compiler, tactic regular expressions
\emph{decrease} the number of generated constraints therefore speeding up the search.
To the best of our knowledge, this is the first use of constraints that leverage the topology structure to simplify the search.

In NetGen network updates that adhere to policies expressed using regular expressions are synthesized using SMT solvers. 
Given a specification which mentions the packet classes, the old path and the new path, NetGen solves the network change problem using a SMT solver. 
Due to the use of regular expressions NetGen also suffers the limitations we just discussed for Merlin.
Interestingly, NetGen uses a specific encoding of regular expressions based on uninterpreted functions that helps 
reducing the number of constraints. While this encoding is fast when updating a single path, we do see a way
to extend it to our global synthesis setting.
A crucial aspect of NetGen is that in its problem formulation each path can be synthesized independently and without affecting the
other already synthesized paths.
This is not the case when supporting isolation policies: if an old path needs to be moved to satisfy a new policy (e.g., because a link is under
maintenance), re-synthesizing such a path can require to re-synthesize other paths.
\loris{we can have a small example of this in appendix.}

\paragraph{Synthesis for SDN}
Program synthesis has been actively applied in software-defined networking. Padon et. al in \cite{decentralize} try to synthesize local forwarding rules for a single switch based on a reactive forwarding policy. One of the important considerations for correctness of forwarding rules is that the controller sees 
all relevant events and rules are not added prematurely. NetEgg \cite{netegg} synthesizes the forwarding policy of a switch using examples of how the switch 
should function when it receives packets. These work deals with synthesis of forwarding behaviour of switches, and cannot be extended to satisfy network-wide policies.  Formal methods and synthesis has 
been used in the context of network updates \cite{updates, customconsistency} which provide network consistency during the process of updates. 

% Write about PGA, NetGen, and efficient update synthesis.

\paragraph{Future directions}
While our synthesis algorithm was focused towards finding a solution for correct policy enforcement,
 there are interesting optimization problems involved: minimizing the length of all paths, maximizing utilisation of the 
 datacenter etc. MaxSMT solvers~\cite{z3maxSMT} to encode these problems.
In MaxSMT, formulas can be labeled as hard and soft constraints and a satisfying assignment
is one that makes all the hard constraints true and as many of soft constraints as possible true.
Moreover, soft constraints can be assigned weights.
We believe that by specifying optimization objectives via the soft constraints many of the problems we mentioned can be encoded.
The ability of MaxSMT solvers such as Z3 to support several different kind of objective functions (e.g., Pareto optimality and ordered objectives)
could be used to turn \Name into a full-blown language able to support complex traffic engineering problems. 
However, MaxSMT solvers
 are much slower than SMT solvers, so leveraging these and achieving tangible performance is one of the directions of future work.
 
