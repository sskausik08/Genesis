\section{Related \& Future Work} \label{sec:relatedwork}

Kang et. al~\cite{oneswitch} tackle a similar problem of flow policy
enforcement. However their end-point policies deal with simple
reachability. Their rule placement algorithm takes the path of the
flow in the network  (the routing policy) as an input.%  and place rules
% on this path to enforce the endpoint policy and taking in
% consideration switch table constraints
\Name tackles the
problem without using the routing policy as input, as we enforce flow
policies which would require different routing policies (like traffic
isolation), so we cannot determine the path of the flow
beforehand. % Our solution can support enforcement of policies which
% require different routing policies.
\cite{distfirewall} builds on the
\cite{oneswitch} abstraction to optimize the specific case of
distributed firewall policy enforcement using ILP.  PGA \cite{pga} is
a graph-level abstraction of specifying network policies like ACLs and
middlebox service chaining. However, it abstracts the underlying
network as "one big switch" and cannot be used to compose policies like
tenant isolation or traffic engineering.

\noindent {\bf Policy languages:}
The closest approaches to ours are Merlin~\cite{merlin} and
NetGen~\cite{netgen}.  In Merlin data planes that adhere to policies
expressed using regular expressions are synthesized by first
intersecting the topology with the regular expressions appearing in
the policies and then encoding reachability in the intersected graph
using mixed integer linear programming (ILP).
%Unlike \Name, 
Merlin can support traffic engineering and load distribution.
Merlin's language does not support isolation policies, but we believe
that it could be extended to support them.  We cannot evaluate the
performance impact of this extension, however.  A more prominent
difference arises with unordered waypoint policies: expressing a
policy including a waypoint set $W$ of size $k$ requires a regular
expression of size exponential in $k$ as all the possible permutations
of the elements of $W$. This fact clearly impacts the performance of
the Merlin's compiler that would have to generate a mixed ILP with a
large number of variables.  In \Name this is not the case as waypoint
can be encoded with polynomially many constraints.  While this does
not affect the theoretical complexity, our compiler does not incur
an a-priori exponential blow-up and it rather relies on the power
of SMT solvers to guide the search.  This is one of the main aspects
behind our decision of not using regular expressions to express
policies.  \Name uses a restricted form of regular expressions to
introduce tactics that leverage the network topology.  While in Merlin
regular expressions \emph{increase} the number of constraints
generated by the compiler, tactic regular expressions \emph{decrease}
the number of generated constraints therefore speeding up the search.
To the best of our knowledge, this is the first use of constraints
that leverages the topology structure to simplify the search.

In NetGen network updates that adhere to policies expressed using
regular expressions are synthesized using SMT solvers.  Given a
specification which mentions the packet classes, the old path and the
new path, NetGen solves the network change problem using a SMT solver.
Due to the use of regular expressions NetGen also suffers the
limitations we just discussed for Merlin.  Interestingly, NetGen uses
a specific encoding of regular expressions based on uninterpreted
functions that helps reduce the number of constraints. While this
encoding is fast when updating a single path, we do see a way to
extend it to our global synthesis setting.  A crucial aspect of NetGen
is that in its problem formulation each path can be synthesized
independently and without affecting the other already synthesized
paths.  This is not the case when supporting isolation policies: if an
old path needs to be moved to satisfy a new policy (e.g., because a
link is under maintenance), re-synthesizing such a path can require
re-synthesizing other paths. 
% \loris{we can have a small example of  this in appendix.}

% \noindent
% {\bf Synthesis for SDN:}
% Program synthesis has been actively applied in SDN for synthesizing the controller. Padon et. al in \cite{decentralize} try to synthesize
% local forwarding rules for a single switch based on a reactive
% forwarding policy.  NetEgg \cite{netegg} synthesizes the forwarding
% policy of a switch using examples of how the switch should function
% when it receives packets. These works deal with synthesis of
% forwarding behaviour of switches, and cannot be extended to satisfy
% network-wide policies.
Synthesis has been used to generate network
updates \cite{updates, customconsistency}, which is orthogonal to \Name.

% Write about PGA, NetGen, and efficient update synthesis.

\noindent
{\bf Future directions:}
\Name focuses on correct policy enforcement, but there are other
interesting optimization problems worth considering: e.g., minimizing
the length of all paths, maximizing utilisation of the datacenter
etc. MaxSMT solvers~\cite{z3maxSMT} can encode these problems.  In
MaxSMT, formulas can be labeled as hard and soft constraints and a
satisfying assignment is one that makes all the hard constraints true
and as many of soft constraints as possible true.  Moreover, soft
constraints can be assigned weights.  We believe that by specifying
optimization objectives via the soft constraints many of the problems
we mentioned can be encoded.  The ability of MaxSMT solvers such as Z3
to support several different kind of objective functions (e.g., Pareto
optimality and ordered objectives) could be used to turn \Name into a
full-blown language able to support complex traffic engineering
problems.  However, MaxSMT solvers are much slower than SMT solvers,
so leveraging these and achieving tangible performance is one of the
directions of future work.
 
