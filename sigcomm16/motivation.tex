\section{Motivation}
\begin{figure}[H]
	\includegraphics[height=5cm]{figures/architecture.png}
	\caption{Rough layout of system architecture. Also will come up with an example figure here.}
	\label{fig:architecture}
\end{figure}
In this section, we describe the type of
policies that network operators and users or tenants may wish to
realize. For simplicity, we assume a multi-tenant cloud set up, where
both the tenants and the provider wish to realize policies over their
respective networks. However, these policies, and our framework, are
applicable to other settings, e.g., enterprise networks with different
departments imposing different sets of policies. The system architecture of 
Genesis is shown in \cref{fig:architecture}.

We use Figure XXX as a running example. \aditya{explain the figure here}.
\kausik{Will do this now}

% \aditya{need to start by saying we focus on multi-tenant clouds, although our system can apply elsewhere too}

% Operators of enterprise and multi-tenant clouds deal with policy
% requirements of different organisations and tenants, as well as
% require support to manage the network for providing QoS guarantees and
% network resource management internally, invisible to the
% tenants. Network operators need to be able to express complex policies
% in an intuitive declarative fashion, and the network management system
% must derive the individual switch forwarding behavior without
% involving the operator.

The high-level policies tenants specify could include:

\begin{itemize}
\item \textbf{Reachability}: Thus ensures network communication
  between specific groups of a tenant's virtual cloud instances,
  applications, or hosts. \aditya{refer here to an example in the
    figure}
\item \textbf{Middlebox traversals}: With the rising prominence of
  middleboxes performing complex packet-processing functions like
  firewalls, intrusion-detection systems etc., tenants may wish to
  express policies which specify the waypoints (locations, or logical
  descriptors) the traffic between two
  endpoints must traverse through.	  
  \aditya{refer here to an example in
    the figure}
    In several cases \loris{how true is this?} the order in which these middle-boxes is traversed
    is not relevant and the policy language should therefore support unordered waypoints.
\end{itemize}
%TODO : MODIFY Synthesis of waypoints to support logical waypoints

Since, cloud tenants do not have a view of the actual physical
topology, the policy requirements for tenants are at a coarser level
of control. However, network operators need a more fine-grained
control of network resources, for which they may desire to specify the
following:

\begin{itemize}
\item \textbf{Isolation}: The current Service Level Agreements (SLAs)
  provided to tenants are centered around compute, storage, or
  external traffic bandwidth. Lack of guarantees on the network
  between tenant instances leads to unpredictability of performance
  for distributed applications. Also, multi-tenant clouds are
  susceptible to attacks on the network by malicious tenants who could
  hog the internal network bandwidth, or conduct side-channel
  attacks~\cite{heyyou-ccs}. % Conventionally,
  % this problem is mitigated by static rate-limiting, but it can lead
  % to under-utilisation of resources.
  Cloud provider can offer (paying) tenants various QoS guarantees
  that enforce varying degrees of tenant isolation. In the extreme,
  this could ensure that a tenant's performance is not affected by
  any other tenant by strictly isolating the path of tenant's flows
  from others' flows. \aditya{refer here to an example in
    the figure}
\item \textbf{Network Resource Management}: To aid traffic
  enginerring, the network operator may specify policies constraining
  the maximum number of tenant flows that can traverse a given link or
  sets of links in the network. He may also wish to ensure traffic
  from some sensitive applications does not contend for bandwidth on
  constrained links with elastic traffic from batch applications.
          %% capacity
          %% of certain links such that tenant flows using the link do
          %% not exceed the capacity of the link. Such policies can be
          %% useful to ensure the low bandwidth links are not used by
          %% more tenants such that their performance is affected and
          %% can be used to provide bandwidth guarantees to tenants.
  Likewise, to tackle hardware heterogeniety, operators can specify
  switch constraint policies, like the size of the rule table to
  restrict the number of flows traversing a particular switch or set
  of switches.
\item \textbf{Network Maintenance}: \aditya{this whole para does not
    parse and needs updating} Operators on a regular basis perform link and
  switch maintenances, and need to ensure that during maintenance, the network still
  conforms to the SLAs of the tenants and resource capacity
  policies.   \aditya{the following sentence does not make sense} Using Genesis, the operator
  can specify the links and switches that will be down for maintenance, and Genesis can synthesize 
  the rules for the updated network with all policies satisfies, which then can be pushed to 
  the network before maintenance. 
\end{itemize}

\subsection{Synthesis} \label{sec:synthesis} 

Providing support for realizing the complex set of policies using
existing SDN programming languages like Pyretic and Frenetic is
challenging, because these policies are global and cannot be enforced
by programming individual behaviour of switches. Existing network
management systems provide support for complex policies including
middlebox placement and bandwidth constraints~\cite{}; however these
are tailor-made for certain policies and lack generality and
extensibility.

We design a general network management system that realizes the above
sets of policies by performing {\em synthesis} of switch forwarding
rules to enforce end-to-end policies. 
Unlike previous efforts in this space (see~\cite{}),
\Name is not tailored to 
specific formalisms such as regular expressions and
this aspect makes it modular  and easily extensible.
%and allows to devise specific
%techniques for each type of policies. 
To draw an analogy with SMT solvers, 
\Name can be seen as a constraint solver
that allows to add different types of policies (respectively the theories in SMT) and
that allows to design different types of optimizations based on the 
policies needed by the user of \Name.

Our work is motivated by recent
progress in program synthesis. \aditya{say more} \kausik{Needed here or in related work?}
Program synthesis is defined as the task of discovering an executable
program from user intent expressed in the form of some
constraints. There are three key dimensions to synthesis: the kind of
constraints that it accepts as expression of user intent, the space of
programs over which it searches, and the search technique it
employs. Program synthesis has seen limited applications to networks,
specifically to controller synthesis~\cite{netegg}, where the idea is
to learn from examples and synthesize the behavior of individual
switches (e.g., learning switches or firewalls); furthermore, this
technique applies to networks operating in a reactive mode (where the
first packet of a connection is processed by the controller to
determine the actions to employ). Like Frenetic and Pyretic, this
switch-centric approach is too constraining.

\Name\ leverages synthesis at a high level as follows: given a set of
policies which describe user intent, the search space is the space of
all forwarding plane configurations and the search technique involved
is SAT/SMT solving. The solution found is implemented by installing
the necessary switch rules via a skeleton controller.

This approach is appealing for a variety of different reasons: 

(1)
Policies useful to operators are \emph{proactive} (i.e., they are not
dependent on the actual packet flow), and our synthesis approach
naturally aligns with such proactive policies.

%  and this enables enforcing policies by synthesis
% of switch-table rules, and using a skeleton SDN controller to deploy
% the forwarding rules to the switches. In contrast, in trying to
% synthesize reactive policies (like a firewall), the controller needs
% to store the state of flows it has received and have a control module
% following the specifications \aditya{huh? this doesn't make sense...},
% which is an interesting synthesis problem, but orthogonal to our
% approach.

(2) Correct policy enforcement is challenging due to different
objectives for each of the policies - ensuring isolation between flows
may lead to overshooting capacity and vice-versa, and is a common
cause of incorrect configurations in networks. 
Our approach removes the need for a verification step in which the operator
has to ``check'' whether an attempt configuration meets the desired policies.
By using a formal
reasoning technique, we are able to consider the space of all
forwarding configurations and find a solution which 
is \emph{correct by construction}
adheres to
satisfying a diverse set of policies, eliminating the room for error
by the network operator. 

(3) Automatically enforcing policies is a task with
\emph{high theoretical complexity}. 
For example, enforcing isolation policies
is as hard as solving
graph-coloring, a well-known
NP-complete problem (see \cref{sec:isolationNP} for the proof).
%, which means
%that any system solving this would need to exhaustively search the
%space of all forwarding plane configurations. 
Many  search
techniques can be used to find the forwarding rules when handling
a particular class of policies, 
but when multiple types of policies are combined (isolation, waypoints, capacity),
devising good search techniques becomes challenging. 
Thanks to the many engineering efforts, SMT solvers abstract away
most of this complexity and allow us
 to unify the search objectives for every policy into a generalised
search technique. 
%Thus, by reducing this problem to a SMT instance and
%leveraging fast off-the-shelf SMT solvers developed over years of
%research, \Name can provide support for diverse policies required by
%network operators. 
Crucially, \Name can be extended with ease to
support new policies without requiring changes to the search
techniques to find the solution.
\loris{I would like to convey that we are in some sense a Network solver module policy,
in the sense that we support theories (the policies) and now people can work on engineering
the solver for different classes of policies.
}
\kausik{To flow from this subsec to the next? Support for policies is 
	inbuilt, but operators can engineer tactics to suit their needs. Is this what you want to convey?}
\loris{I found many words used to address the same concept:
enforce the policies, synthesize rules, etc...
try to be uniform or it's quite hard to understand what is being done.
} 
\kausik{I think "enforce policies" would be better? The title explains the rest.}
\subsection{Performance Challenges} \label{sec:performance}

One of the key challenges of Genesis is the synthesis
performance. There is a trade-off between the generality of the model
to enforce various different objectives versus the size of the problem
provided to the solver.  Since finding a solution has exponential time
complexity in the number of policies, in theory the time to
synthesize the rules increases exponentially. Since \Name supports policies
 which affect the path of two different flows like isolation, we cannot
 reason about these related flows separately. \aditya{the following sentence does not flow
  from the previous} 
  %Thus, a greater number of policies leads to a
%bigger problem instance to the solver. 
Despite the recent advances in SMT solvers, there is a need to improve the performance
using different techniques specific to this problem.


In this paper, we propose various techniques leveraging
\emph{domain-specific} knowledge to improve synthesis performance. We
propose the idea of \emph{tactics} (\cref{sec:tactic}), which are
search strategies leveraging the network structure of datacenter topologies, 
to specify properties of the paths for the reachability policies.  Tactics are 
a way for network operators to specify a high-level constraint on the set 
of paths allowed for reachability policies. 
Path properties are expressed using a simplified form of regular expressions which,
after being converted into a finite automata,
can be used
to simplify the set of constraints provided to the solver.
In particular, one can eliminate constraints that cannot be true for any of the paths
accepted by the automaton language. 
\loris{too many parentheses, hard to read. Break into two sentences}
\loris{describe a bit what a tactic is at the high level: a high level constraint
	describing sets of allowed paths?}


Another
property of datacenter topologies is that the huge interconnect of
links can lead to multiple solutions to the problem. 
To take advantage of this property, we design a
heuristic synthesis prodecure called \emph{optimistic} synthesis
(\cref{sec:optimistic}) which leverages the structure of policy
interactions to partition the input policies
into effective components and synthesize these components 
faster than the complete problem. To improve the performance of the heuristic, 
we use recovery techniques which uses Z3's feature of extracting 
unsatisfiable cores to converge to a correct solution faster by performing 
a guided enumeration.
\loris{one or two more sentences?}

