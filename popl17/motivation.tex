\section{Motivation}
\begin{figure}
	\includegraphics[width=\columnwidth,center]{figures/architecture.eps}
	\compactcaption{\Name in a multi-tenant datacenter setting.}
	\label{fig:architecture}
\end{figure}

\input{policy}

We describe the type of policies desired in multi-tenant data centers
that \Name supports.
%% For simplicity, we assume a multi-tenant cloud set up, where both
%% the tenants and the provider wish to realize policies over their
%% respective networks. However, these policies, and our framework,
%% are applicable to other settings, e.g., enterprise networks with
%% different departments imposing different sets of policies.
We use \Cref{fig:architecture} as a running example. A tenant is an
entity which controls a number of host machines running some applications,
and specifies policies about the paths among it's hosts which need to be enforced
by the network operator. \Cref{fig:architecture} shows several
tenants who differ in the nature of policies they wish to realize. 
Notice that these policies reflect and, in some cases, extend the
policies that today's enterprises realize in their on-site networks, as
well as the policies that data center operators support for the different 
tenant 
workloads~\cite{mpa-imc15}.  The policies include:

%\aditya{explain the figure here}.
%\kausik{Will do this now}

%\aditya{define flow, flow group, policy etc here}
% \aditya{need to start by saying we focus on multi-tenant clouds, although our system can apply elsewhere too}

% Operators of enterprise and multi-tenant clouds deal with policy
% requirements of different organisations and tenants, as well as
% require support to manage the network for providing QoS guarantees and
% network resource management internally, invisible to the
% tenants. Network operators need to be able to express complex policies
% in an intuitive declarative fashion, and the network management system
% must derive the individual switch forwarding behavior without
% involving the operator.


\begin{compactitemize}
\item \textbf{Reachability}. This enables network communication
  between specific groups of a tenant's virtual instances (VMs),
  applications, or hosts. For example, the yellow tenant has defined a
  reachability policy for its VMs ($V1 >> V2$, which is translated
  after VM placement as $E2 >> E4$).
\item \textbf{Middlebox Traversals}. A tenant may wish that traffic
  between two of her end hosts, or from another tenant, must traverse
  specific middleboxes %(locations, or logical descriptors) for
  security, access control, or performance reasons. For specific
  flows, tenants can provide a sequence of unordered sets of
  middleboxes
  %\loris{flow group is not defined, group of flows or set of flows?} 
  to traverse. The flows must traverse these sets in order,
  while in a set, all middleboxes must be traversed
  and the order is irrelevant.  The
  unordered set abstraction leverages the fact that middleboxes
  without dependencies in their traffic processing behavior can be
  placed in any order relative to each other~\cite{pga}. For example, the grey tenant in \Cref{fig:architecture}
  defines a waypoint policy $V1 >> FW; [IDS,BC] >> V2$
   which specifies that traffic must first pass through the firewall (FW),
  and then through the IDS and the byte counter (BC) in any order. 

  %% \aditya{refer here to an example in
  %%   the figure} In several cases \loris{how true is this?} the order
  %% in which these middle-boxes is traversed is not relevant and the
  %% policy language should therefore support unordered waypoints.

\item \textbf{Isolation}. Tenants may require various QoS guarantees
  that enforce varying degrees of isolation for their traffic. In the
  extreme, a tenant could require that her flows are not affected by
  any other tenant by strictly isolating the path of the tenant's
  flows from others' flows. In \Cref{fig:architecture}, we have two
  tenants whose traffic will be isolated from one another, i.e., the
  paths used by the tenants will not share any links in the topology.
  A tenant could also specify isolation for a subset of her
  (performance-sensitive) flows from other flows of the same tenant or
  those belonging to other tenants; the rest of the tenant's flows may
  require no guarantees.

%%   There has been a rising emergence of 
%% multi-tenant clouds, which is more economical for tenants to use
%% rather than managing their own private datacenters. However,
%% the current Service Level Agreements (SLAs)
%% provided to tenants are centered around compute, storage, or
%% external traffic bandwidth. Lack of guarantees on the network
%% between tenant instances leads to unpredictability of performance
%% for distributed applications. Also, multi-tenant clouds are
%% susceptible to attacks on the network by malicious tenants who could
%% hog the internal network bandwidth, or conduct side-channel
%% attacks~\cite{heyyou-ccs}.
% Conventionally,
% this problem is mitigated by static rate-limiting, but it can lead
% to under-utilisation of resources.
%% Cloud provider can offer (paying) tenants various QoS guarantees
%% that enforce varying degrees of tenant isolation. In the extreme,
%% this could ensure that a tenant's performance is not affected by
%% any other tenant by strictly isolating the path of tenant's flows
%% from others' flows. \aditya{refer here to an example in
%% 	the figure} The tenant could also specify isolation for certain
%%  performance-sensitive flows, while the rest of the tenant-flows
%%   would be without guarantees with varying degrees of pricing. 
%%   Thus, support for isolation is an important feature in multi-tenant 
%%   networks. 
 
%TODO : MODIFY Synthesis of waypoints to support logical waypoints
%% Since, cloud tenants do not have a view of the actual physical
%% topology, the policy requirements for tenants are at a coarser level
%% of control. While support for the above policies can be used to satisfy tenant
%% SLAs, network operators can benefit from a fine-grained
%% control of network resources, integrated with support for tenant specifications 
%% for effective management of the network. \newline

%\loris{is there a reason why this is not in the itemize?} 
%\kausik{This is not a tenant policy, but an operator feature, so separate from itemize.}
\item \textbf{Network Resource Management}. While support for the
  above policies can be used to satisfy tenant SLAs (service-level
  agreements), network operators benefit from being able to enforce
  strict network resource constraints, or optimizing an objective such
  as total utilization of the network links or restricting traffic on
  certain links. For example, in \Cref{fig:architecture}, the red
  links are of low bandwidth, and the operator wants to ensure traffic
  on these links do not exceed the link capacity of 100.
%For instance, to aid traffic engineering, the network
%operator may specify policies constraining the maximum number of
%tenant flows that can traverse a given link or sets of links in the
%network. She may also wish to ensure that traffic from some sensitive
%applications does not contend for bandwidth on constrained links with
%elastic traffic from batch applications. For example, in \Cref{fig:architecture},
%there are two low-bandwidth links in the datacenter, and the operator
%specifies policies to ensure that flows traversing $A2 \rightarrow C2$ 
%and $A2 \rightarrow C4$ do not exceed the link capacity of 100.
          %% capacity
          %% of certain links such that tenant flows using the link do
          %% not exceed the capacity of the link. Such policies can be
          %% useful to ensure the low bandwidth links are not used by
          %% more tenants such that their performance is affected and
          %% can be used to provide bandwidth guarantees to tenants.
  Likewise, to tackle hardware heterogeneity, operators can specify
  switch constraints, e.g., the maximum size of the rule table to
  restrict the number of flows traversing a particular switch or set
  of switches.
 
 \item \textbf{Handling Failures}. Modern networks experience link and switch failures
 frequently and an essential requirement in network management systems is to
 provide certain guarantees during failure scenarios. 
 %\name addresses this by
 %providing two mechanisms: minimal network repair and resilience
 synthesis.  When a failure occurs, we must reconfigure the forwarding
 rules such that the policies are satisfied. Naively performing this
 process can result in a solution which incurs a large time overhead
 of installing the new rules (controller has to set up connections
 with alive switches and send new rules). It is therefore desirable to
 have minimal network repair which aims to minimize the overhead of
 transitioning from an old data-plane to a new policy-compliant
 one. While repair is a reactive approach to failures, the transition
 under failures can be expensive. Thus, as an alternative to minimal
 repair, it may be desirable to proactively configure switches with
 resilient policy-compliant backup paths (at the expense of additional
 switch rules).
\end{compactitemize}


\noindent Realizing these policies requires painstaking, often
manual configuration of diverese network devices. This is incredibly
tedious---the configuration files can run into 1000s of lines, and
intricate dependencies may have to be configured across
devices~\cite{benson:complexity:nsdi2009,mpa-imc15}. This process is
also highly error prone~\cite{mpa-imc15}. Even programming with SDN
languages like Pyretic and Frenetic is challenging as these policies
are global and cannot be enforced by programming individual behavior
of switches.  While some existing SDN-based network management
systems~\cite{simple,merlin,oneswitch} overcome these limitations,
they are tailored to support specific policies such as middlebox
placement or bandwidth and resource constraints. As such they lack
generality and extensibility required to enforce the complex
collection of policies.


\subsection{Data Plane Synthesis} \label{sec:synthesis} 


We design \name, a general network management system that 
 performs {\em synthesis} of switch forwarding
rules to enforce the above set of end-to-end policies (specified using 
GPL as shown in \Cref{tab:policysupport}). The architecture of \name
is shown in \Cref{fig:architecture}.

Unlike previous efforts in the network synthesis space ~\cite{netgen,merlin}, \Name is
not tailored to specific formalisms such as regular expressions; 
this aspect makes it {\em modular} and {\em easy to extend}.
%and allows to devise specific
%techniques for each type of policies. 
To draw an analogy with SMT solvers, \Name can be seen as a constraint
solver that allows the addition of different types of policies
(respectively, theories in SMT) and that allows the design of
optimizations based on the properties desired by 
  operators using \Name. 
  
  Our work is motivated by recent advances in program synthesis, i.e.,
  the task of discovering an executable program from user intent
  expressed in the form of some constraints. There are three key
  dimensions to a synthesis problem: the type of constraints that it accepts as
  expression of user intent, the space of programs over which it
  searches, and the search technique it employs. 
\Name\ leverages synthesis as follows: given a set of
policies which describe user intent, the search space is the space of
all data planes (the set of forwarding rules is the data plane) 
and the search technique involved
is SAT/SMT solving. 

This approach is appealing for the following reasons: 

(1)
Enforcement of the different policies useful to operators 
can be translated to 
the following problem: Given a set of node pairs 
(derived from the reachability policies) in the graph 
(network topology), find paths in the graph for each
of the node pairs satisfying certain properties (derived
from the rest of the policies). 
Thus, the different policies can be enforced by 
a correct set of forwarding rules at the switches. 
No extra functionality is required from the controller,
its only role is to install the forwarding rules on switches.

%Given these paths, the SDN
%controller adds the forwarding rules accordingly
%in the network, and no extra functionality is required from
%the controller. 
%Policies useful to operators are \emph{proactive} i.e., 
%for packets matching 

%they are not
%dependent on the actual packet flow and can be enforced by 
%correct switch tables, and do not require synthesis of controller programs.
%  and this enables enforcing policies by synthesis
% of switch-table rules, and using a skeleton SDN controller to deploy
% the forwarding rules to the switches. In contrast, in trying to
% synthesize reactive policies (like a firewall), the controller needs
% to store the state of flows it has received and have a control module
% following the specifications \aditya{huh? this doesn't make sense...},
% which is an interesting synthesis problem, but orthogonal to our
% approach.

(2) Correct policy enforcement is challenging due to different
objectives for each of the policies --- ensuring isolation between
paths may lead to overshooting traffic objectives and vice-versa ---
and is a common cause of incorrect configurations in networks.  Our
approach removes the need for a verification step in which the
operator has to ``check'' whether the forwarding rules satisfy the
desired policies.  By using a formal reasoning technique, we are able
to consider the space of all data planes and find a solution which is
\emph{correct by construction}, eliminating the room for error by the
network operator.

(3) Automatically enforcing policies is a task with \emph{high
  theoretical complexity}.  For example, enforcing isolation policies
is as hard as solving graph-coloring, a well-known NP-complete
problem.  Many search techniques can be used to find the forwarding
rules when handling a particular class of policy, but when multiple
types of policies are combined, e.g., isolation, waypoints, and
traffic engineering, devising good search techniques becomes
challenging.  Thanks to the many engineering efforts, SMT solvers
abstract away most of this complexity and allow us to unify search
objectives for every policy into a generalized search technique.
%Thus, by reducing this problem to a SMT instance and
%leveraging fast off-the-shelf SMT solvers developed over years of
%research, \Name can provide support for diverse policies required by
%network operators. 
Crucially, \Name can be extended with ease to support new policies
without requiring changes to the underlying search techniques. To
further improve the search/synthesis performance, \name uses two techniques
specific to policy enforcement to speed up synthesis: tactics
(\secref{sec:tactic}) and divide-and-conquer synthesis
(\secref{sec:optimistic}).
%% \loris{I would like to convey that we are in some sense a Network solver module policy,
%% in the sense that we support theories (the policies) and now people can work on engineering
%% the solver for different classes of policies.
%% }
%% \kausik{To flow from this subsec to the next? Support for policies is 
%% 	inbuilt, but operators can engineer tactics to suit their needs. Is this what you want to convey?}
%% \loris{I found many words used to address the same concept:
%% enforce the policies, synthesize rules, etc...
%% try to be uniform or it's quite hard to understand what is being done.
%% } 
%% \kausik{I think "enforce policies" would be better? The title explains the rest.}


%\subsection{Performance Challenges} \label{sec:performance}
%
%\loris{I feel like this section is a repeat of the end of the intro.
%If you need a place to cut this is the one.
%I have a bit of the same feeling about 2.1 but that one at least motivates something.
%}
%
%One of the key challenges of \Name is the synthesis
%performance. 
%Due to the rich set of policies supported by \Name,
%finding a consistent set of switch forwarding rules 
%has, in the worst case, exponential time complexity in
%the number of policies.
%Moreover, since policies such as isolation affect
%the paths of many different flows, it is not possible to incrementally synthesize
%the forwarding rules corresponding to each flow. 
%Despite the recent advances in SMT solvers, to make
%the synthesis problem feasible in practice
%there is a need to improve the performance of the solver
%using techniques that are specific to policy enforcement in networks.
%We propose two such tecnhiques.
%
%First, we propose the idea of \emph{tactics} (\secref{sec:tactic}),
%which are search strategies that leverage the tiered network structure
%of datacenter topologies.
%%, to specify properties of the paths for the reachability
%%policies.  
%Tactics allow network operators to provide a high-level description on
%the set of paths allowed for reachability policies.  Tactics are
%expressed as simplified forms of regular expressions, which can be
%used to reduce the set of constraints provided to the solver.  In
%particular, we eliminate constraints that cannot be true for any
%of the paths accepted by the language of the regular expression. We
%find that this can result in 1.5x-400x speedup in various settings.
%
%Second, we propose a divide-and-conquer procedure that takes advantage of the fact that in 
%datacenter topologies, the large
%interconnect of links can lead to multiple solutions 
%to enforce the provided policies.  
%The divide-and-conquer
%synthesis approach (\secref{sec:optimistic}) leverages the structure of
%isolation policy graph among tenants to partition the input
%policies into components and synthesize these components separately and
%faster than the complete problem. This approach uses
% unsatisfiability cores provided by the solver
%to converge faster to the correct solution. 


