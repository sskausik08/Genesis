\section{Introduction}
%% Conventionally, a network primarily acted as a backbone for
%% communication among machines, and these communications used the
%% ``shortest" path in the network based on certain metrics for deciding
%% the path between two machines.  Today,

Many enterprises are increasingly migrating their on-premise IT
infrastructure to cloud datacenters. In such environments, the
different enterprises (tenants) share different resources, such as,
the compute machines that run their applications and network
infrastructure used for communication among these applications.
Operators of such multi-tenant datacenters thus have to deal with a
multitude of machines communicating with each other (flows) over a
network that is composed of many tens to hundreds of routers or
switches (devices)~\cite{mpa-imc15}. With growing diversity of
enterprise applications and the need for security and compliance,
these pathways of communication through the datacenter network are
subject to increasingly complex network-based policies.

Consider an enterprise tenant in such a datacenter. She may desire
basic communication among her applications along shortest paths based
on certain metrics (reachability). In addition, she may wish that
traffic attempting to reach some of her applications be examined by a
set of ``middleboxes'' for auditing and access control
(traversal). Another tenant may additionally desire a subset of her
flows not share any infrastructure with others' flows for strong
security or Quality-of-Service considerations (isolation).  In
parallel, cloud operators must meet key operational requirements. For
instance, they often need to optimize network performance objectives
(traffic engineering), e.g., minimizing the maximum load imposed by
all tenants on network links, and deal with heterogeneous resource
constraints such as switch table sizes. Also, since datacenter
networks are highly prone to link/switch
failures~\cite{gill-sigcomm11}, operators often need to ``repair" the
network data plane to re-enforce policies. For stricter guarantees
during failure scenarios, operators additionally desire a mechanism to
proactively configure devices to enforce policies under a bounded
number of failures (failure resilience).

Today, configuring network devices to implement these diverse and
complex policies in aggregate is manual, ad-hoc, and error-prone.
This can lead to misconfigurations and violations of tenant
service-level agreements (SLAs) which can have a severe performance
and security impact.

%%  However, in real-life, the
%% process of policy enforcement by network operators is manual and
%% ad-hoc, leading to violations of service-level agreements and
%% mis-configurations which have severe performance and security
%% impacts. With the boom in cloud services, datacenter networks deal
%% with thousands of flows which are not constant, but in flux, thus,
%% making it difficult to enforce them in an ad-hoc manner.

%% Network operators desire various different end-to-end policies to
%% support in clouds and enterprise networks. Tenants or organisations
%% require support for basic policies like reachability between hosts,
%% and specifying different middlebox policies for certain
%% flows. Operators, on top of that require support for complex policies
%% like traffic isolation between flows to provide fairness and
%% specifying resource constraints like link bandwidth and switch table
%% sizes to perform traffic engineering and network resource management.

The rise of \emph{software-defined networking} (SDN) has allowed
operators to program networks in a more intuitive manner. In SDN, a
general-purpose centralized controller machine (control plane)
controls end-to-end communication pathways by managing network
forwarding rules on a collection of programmable switches (data
plane). Using a global view of current network topology, the
controller can program forwarding rules on switches based on
application requirements.
%However, many existing SDN
%frameworks are too low-level, 
%making it challenging 
%to write controller applications using these which generate 
% the data plane enforcing the above policies. %% For many
%% of the policies, generating the data plane is an NP-complete problem
%% and requires the design of efficient custom heuristics; combining
%% different policies' heuristics together is non-trivial.
Unfortunately, existing SDN programming languages (e.g.,
Frenetic~\cite{frenetic} and Pyretic~\cite{pyretic}) are too
constraining: operators would ideally want to specify and realize
policies network-wide, whereas these languages focus on programming
{\em individual} switch behaviors.  Moreover, for many types of
policies, generating a data plane that enforces them is a
%  an NP-complete 
computationally hard problem, requiring the design of efficient custom
heuristics {\em per policy type}. Other recent works on network-wide
policy enforcement~\cite{merlin,simple} go beyond the single-switch
model, but they target specific types of policies and thus are
difficult to extend to other commonly desired policy types (e.g.,
isolation).
%; combining  different policies' heuristics together is non-trivial. 
 %% \aditya{we need to be
% careful
%%   not to bin all SDN languages into this switch-by-switch model}
%% \kausik{Do you want to make changes here?}







%% support
%% other kinds of policies such as traffic isolation.

%%  like
%% joint bandwidth provisioning and waypoint routing in Merlin
%% \cite{merlin}, and middlebox policy enforcement in SIMPLE
%% \cite{simple} or FlowTags~\cite{flowtags}. However, these approaches

In this paper, we seek a {\em general} approach that allows a variety
of rich policies to be specified as the input, with the output being
the corresponding set of switch forwarding rules such that the
complexities of correctly realizing the policies in the data plane are
hidden from operators. This is an important step toward {\em
  intent-based networking}~\cite{intent}, where operators specify {\em
  what} they want the network to do instead of worrying about {\em
  how} the network must be configured.
%their networks. %% To support a cornucopia of policies, an
%% important feature is \emph{generality} of the approach of policy
%% enforcement, so that it can be extended to enforce custom policies
%% required by the operator.
This paper makes a case for using \emph{data plane synthesis} as a
practical approach to realizing this vision in the multi-tenant
datacenter context.
%% switch
%% table forwarding rules to the solve the problem of policy enforcement
%% by use of off-the-shelf SMT-solvers.

We present \Name, a framework for {\em declaratively} specifying and
enforcing complex policies, such as, isolation, capacity constraints,
middlebox traversals, and failure resilience. To tackle the high
complexity of enforcing some of these policies (for e.g., enforcing
isolation is NP-complete), \Name encodes the problem as that of
constraint solving and leverages recent advances in fast
Satisfiability Modulo Theories (SMT) solvers to efficiently search for
a solution to the constraints.  The solution is then translated into
switch forwarding rules.
%Using SMT solvers with 
%support for linear optimization, \name can perform traffic engineering, and
%minimal network repair. We extend \name to synthesize
%resilient switch tables to \emph{proactively} ensure policy-compliance
%in failure scenarios. 
%% This
%% paper presents Genesis, a
%% network management tool where the network operators can express the
%% network-wide policies in a high-level declarative manner and Genesis
%% will synthesize the lower-level switch forwarding rules for realising
%% these policies, eliminating the need for operators to work on
%% switch-level behaviours. 
By leveraging the formal guarantees of constraint solving, \Name
eliminates the room for error in the enforcement of complex
policies.

%\kausik{Do we need to make the point of sacrificing performance for generality for POPL? }

Unfortunately, due to the the large space of forwarding plane
configurations, naively encoding policies using SMT solvers results in
impractical synthesis speeds (up to 100s or even 1000s of seconds in
the median case; \secref{xxx}).
%enterprise networks today because the space of forwarding plane configurations
%is huge. 
To make synthesis more practical, \Name leverages domain-specific
properties to simplify the constraints handled by the SMT solver.
We allow the network operator to write restricted
forms of regular expressions, called \emph{tactics}, that blacklist
paths based on certain patterns that are not desired in a datacenter
network.
%\loris{how about: ...based on path patterns that are not desired...}
These tactics are used to discard several constraints, 
acting as a search strategy for the solver.
%\aditya{the previous sentence is vague}
%By identifying a restricted syntax for specifying
%tactics, we 
Tactics can improve the synthesis procedure and achieve
%constraints added to the solver without additional constraints
%required to ensure the solution satisfies the tactic and achieve
a 1.5$\times - $400$\times$ speedup (median speedup:
XXXX).\aditya{fix me}

 Secondly, we develop a \emph{divide-and-conquer} synthesis procedure
 that leverages the relationships among tenants' isolation policies to
 improve synthesis performance. The procedure partitions the input
 policies into effective components such that \name can synthesize
 these components separately and faster than the complete problem.
 Divide-and-conquer synthesis can halve the synthesis time for 40\% of
 workloads with isolation policies.
 %% which vary in size and complexity
 %% of isolation.
 %\aditya{is this statement correct? what is 40\% of scenarios?}
 %\aditya{the
   %previous sentence is vague} 

%% are
%% huge, and by supporting a set of diverse and complex policies with
%% different search objectives, we require to create a model general and
%% expressive enough to support these. This poses a challenge as to can
%% synthesis performance be improved by leveraging knowledge specific to
%% the problem of policy enforcement in networks?

%We implement \Name using ... We evaluate it using .... Key highlights .... \aditya{all of these are todo}.\kausik{Do we need a para or will the next para suffice?}
\noindent \textbf{Contributions.} \ \ \ Our contributions are the following.
\begin{compactitemize}
\item An extensible declarative framework for describing
  complex policies and a modular SMT-based algorithm for enforcing policies
  like isolation, waypoints (\secref{sec:synthesisalgo}), traffic engineering~(\secref{sec:optimization}), and 
  failure resiliency (\secref{sec:resiliency});
\item A modified synthesis algorithm based on tactics, which leverages datacenter network structure
  to blacklist undesirable path patterns (\secref{sec:tactic});
\item A divide-and-conquer procedure for speeding up synthesis by leveraging the 
structure of policy interactions (\secref{sec:optimistic});
\item An implementation of \Name and an extensive evaluation on different policy workloads, topologies and multi-tenancy settings (\secref{sec:evaluation}).
		%to quantify the performance of Genesis. 
\end{compactitemize}
%\aditya{todo}

\iffull\else
A long version
of this paper containing all the proofs has been submitted as supplementary material.
\fi
%% : We present the design and implementation of a network management
%% system with support for a diverse set of complex end-to-end
%% policies like isolation, waypoints and capacity. We designed a
%% novel search strategy using regular expressions to prune the space
%% of forwarding plane configurations by leveraging the network
%% structure to provide properties of the path, especially in
%% datacenter topologies. Lastly, we design a heuristical synthesis
%% routine leveraging the nature of policy interactions to improve
%% synthesis performance.
