\section{Synthesis with Optimization Objectives}
\label{sec:optimization}

While SMT solvers provide support for different theories like SAT and
LRA to express various policies as seen in \secref{sec:synthesisalgo},
operators additionally need to optimize different metrics of the
network. Using extensions of solvers with support for linear
optimization objectives and MaxSMT~\cite{maxsmt}, \name has support
for two applications important to network management: traffic
engineering and network repair.

\subsection{Traffic Engineering}
While the link capacity policies described in \secref{sec:linkcap} can
be used to perform a strict form of traffic engineering (TE) in terms
of adhering to link bandwidths, it is often more useful to balance
traffic across links (because, a link failure will affect fewer flows
when the flows are spread evenly across the network).  To this end,
network operators often impose traffic engineering objectives such as
minimizing the total link utilization or the maximum link utilization.
%% useful in balancing traffic across links,
%% and a link failure will affect lesser number of flows when the flows
%% are spread evenly across the network.

\paragraph{Min-tot TE}
To perform traffic engineering, link capacities of the network $C(sw_1, sw_2)$ and traffic 
rates of the packet classes $\sigma(pc)$ are specified as input to \name (we assume a single
path for a packet class). The utilization 
of a link $U(sw_1, sw_2)$ is defined as the ratio of total traffic flowing through the link to the 
link capacity, and encoded using the theory of linear rational arithmetic as:
\begin{equation}
U(sw_1, sw_2) = \frac{\sum_{\forall pc} \texttt{ite}(Fwd(sw_1,sw_2, pc), \sigma(pc), 0)} {C(sw_1, sw_2)}
\end{equation}
The objective for minimizing total link utilization is as follows:
\begin{equation}
	\texttt{minimize}\ \sum_{\forall sw_1, sw_2} U(sw_1, sw_2)
\end{equation}
\paragraph{Min-max TE}
To encode the TE objective of minimizing the maximum link utilization, we define
a variable $maxU$, and constraints to ensure that $maxU$ is greater than or equal to all 
individual link utilizations, and the objective: 
\begin{equation} \label{eq:maxu}
\forall sw_1, sw_2.\ \ maxU \geq U(sw_1, sw_2)
\end{equation} 
\begin{equation}
		\texttt{minimize}\ maxU
\end{equation}
While $maxU$ can be set to a large value trivially to satisfy \Cref{eq:maxu}, 
since the objective is to minimize $maxU$, it will be set to the actual
minimized maximum link utilization. Using an encoding similar to the one presented in this section, \name can be used for other
quantitative objectives like minimizing total latency and load balancing
traffic across middleboxes.

\subsection{Network Repair}
While policy-compliance is a major requirement in a network management system,
another important consideration is the frequent occurence of failures (switches, links etc.),
which require recomputation of paths compliant to the policies for the modified topology. 
While a naive approach is to use \name to resynthesize the modified instance,
the new solution may be drastically different from the original data plane, incurring a
large overhead of installing the new rules~\cite{sdnlatency,updatescheduling}. Thus, operators
need a \emph{network repair} mechanism which can transition with minimal
overhead from the current
data plane to a policy-compliant one. 
This repair mechanism is also useful to accomodate incremental policy
changes, which occurs frequently in cloud datacenters~\cite{mpa-imc15}. 
For the new set of policies, \name can use repair to synthesize
a new data plane with minimal overhead of installation.  

We extend \name's synthesis algorithm for performing
minimal network repair using MaxSMT.  
Formally, the MaxSMT problem is as follows: given a set
of formulas $\Psi_0, \Psi_1, \ldots \Psi_n$ with associated 
weights $w_1, \ldots w_n$, find a subset $M \subseteq \{1, \ldots n\}$
s.t: 
\begin{compactenumerate}
	\item $\Psi_0 \wedge \bigwedge_{i \in M} \Psi_i$ is satisfiable.
	\item The \emph{award} $\sum_{i \in M} w_i$  is maximized.
\end{compactenumerate}
The constraints $\Psi_1, \ldots \Psi_n$ denote \emph{soft} constraints, and
the weights $w_i$ encodes the award for including $\Psi_i$ in the satisfying
assignment. 
%The basic intuition is that
%we add the existing configuration as \emph{soft} constraints to the set of \emph{hard} 
%policy constraints. The solver would return a solution which \emph{maximizes} the 
%number of satisfied soft constraints (the older configuration),
%thus resulting in a new policy-compliant forwarding 
%configuration with minimal 
%number of changes from the older one and reducing the overhead of
%updating the forwarding rules in the network.  

We reduce network repair to a MaxSMT problem
such that 
the number of switches on which rules needs to be updated is minimized.
 Let
the policy constraints generated by \name for the new network state be $\Psi_0$, and the present 
configuration is $\overline{Fwd}$ which does not satisfy $\Psi_0$. The 
objective is to find new $Fwd$ which satisfies $\Psi_0$ such that the number of \emph{preserved switches} (switches whose rules are unchanged) 
is maximized. If the rules on switch $sw_i$ are preserved, then $Fwd$ and $\overline{Fwd}$ have the same forwarding rules for all packet classes which
traverse through $sw_i$. The MaxSMT constraints are described as follows:
\begin{equation}
	\Psi_{sw_i} =  
	  \bigvee_{\mathclap{\substack{\forall sw_j, pc \\
			  		(sw_i, sw_j, pc) \in \overline{Fwd}}}} Fwd(sw_i, sw_j, pc) 
			~~~~~~~~~~~ 
			w_{sw_i}= 1
\end{equation}
By providing $\Psi_0, \Psi_{sw_1}, \ldots, \Psi_{sw_n}$ and associated
weights $w_{sw_1},$ $\ldots w_{sw_n}$ to a MaxSMT solver, we can
synthesize new forwarding rules \emph{minimizing} the number of
switches whose rules have to be changed.  Alternate repair objectives
like minimizing the number of changed forwarding rules can be
expressed similarly. Note that, interestingly, \name's network repair
mechanism described above can also be used to transform existing
non-policy compliant network data plane to a policy-compliant one.

%\name is provided the policies
%and the current forwarding rules $(\overline{Fwd})$ as input. The policy constraints are added as hard
%constraints as described in the earlier sections. To maximize the number of unchanged
%switches, we add \emph{soft} constraints for each switch $sw_1$ of uniform weight as follows:
%Thus, the new forwarding rules $Fwd$ will maximise the number of unchanged
%switch rules in $\overline{Fwd}$, because the constraint will be unsatisfied if a rule on the
%switch changes. 


 







 
