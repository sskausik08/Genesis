\section{Routing Model and Problem Definitions}
In this section, we formally define the problems addressed in this
paper.  We first describe the representation of different
routing protocols; we model static
routes, OSPF shortest-path routing, and BGP preference-based routing.
Then, we define what it means for a configuration to meet a given
set of policies and present the configuration synthesis problems
we tackle.
Finally, we formalize two resilience metrics called 
connectivity-resilience and positive-resilience,
which we will use in our experimental evaluation.


\subsection{Routing Model} \label{sec:routingmodel}

We represent the physical router topology as a directed graph $T=(V, L)$,
where $V$ is the set of routers and $L\subseteq V\times V$ is the set of links. 
Throughout the paper we assume $T$ is fixed.
We use the neighbour function $N(s) = \{s'\ | \ (s,s') \in L \}$ to denote 
the set of neighbour routers of $s$. 
We define $\Lambda \subset IP$ to denote the set of 
destination IP addresses;
distributed protocols make forwarding decisions based on the 
destination address/subnet.

A path $\pi = (u_1,v_1) (u_2, v_2) \cdots (u_n, v_n) \in L^*$ is a 
loop-free valid path if
a  vertex is not visited more than once---i.e.,
$u_1\neq v_n\wedge\forall i,j \leq n. 
~i \not= j \rightarrow u_i \not= u_j$---and all adjacent links in the
path share a router---i.e., $\forall i < n. ~v_i = u_{i+1}$.
Sometimes we represent the path $\pi$ as $u_1\rightarrow u_2 \rightarrow  \cdots \rightarrow u_n \rightarrow v_n$.
We define a predicate $valid(\pi)$ to denote that $\pi$
is a loop-free valid path. 
We write $l \in \pi$ when the path $\pi$ contains the link $l$. 

Hierarchical control planes partition the
network into multiple connected components called domains 
to scale routing to large networks. To model hierarchical 
control planes, 
we define a router domain assignment function
$\Theta: V \mapsto \nat$ which maps each router to a domain 
(denoted by a natural number). In this paper, we assume 
each domain uses OSPF as the intra-domain routing protocol
and BGP as the inter-domain routing protocol. 
We describe
the routing model for each protocol independently
and then show how protocols can be combined. 

% In the 
%rest of the section, we describe each component 
%of the configuration $C$ and the routing function 
%$\route^C: V \times \Lambda \mapsto 2^V$ for 
%the network given the configuration $C$. 
%\kausik{Remove this simplifying assumption
%We assume the following  
%simplifying property for $C$: for any two 
%routers $r_1$ and $r_2$,
%traffic will be forwarded from $r_1$ to $r_2$ 
%along a single path. 
%When synthesizing $C$, we will ensure that this property is satisfied.}


\minisection{Static Routes} Static routing refers to a router using a
manually-configured routing entry, rather than information from
dynamic protocols like OSPF or BGP.  Static routing is useful to enforce certain
paths that are not realizable using routing protocols because 
static
routes for a given destination have the highest preference over other routes for the same destination.  
We define the static route partial
function $SR: V \times \Lambda \mapsto 2^V$ with the following meaning:  
given a router $r$
and destination $\lambda$, if $SR(r,\lambda)=\{r_1, r_2\}$, then router
$r$ forwards traffic for $\lambda$ to routers 
$r_1$ and $r_2$.    

\minisection{OSPF} Open Shortest Path First (OSPF) is a routing
protocol commonly used inside a domain. In OSPF, routers receive link
state information from other routers and use it to create a map of
the network. Each link is associated with a positive weight and traffic from a router $r$ to
a destination $\lambda$ is forwarded across 
the shortest path from $r$ to $\lambda$.

We define the OSPF weight function $W: L \mapsto \rat$ which 
maps edges of the topology to positive rational weights.  
For two routers $s$ and $t$ in the same OSPF domain, 
we define the distance function $D:V \times V \mapsto \rat$ 
to be the weight of the shortest OSPF path between two routers
belonging to the same OSPF domain with respect to the  
OSPF weight function $W$.
We define the gateway function 
$G: \nat \times \lambda \mapsto 2^V$ to denote the gateway routers 
in a domain which provide a route to $\lambda$. If $\lambda$ 
is directly connected to a single router $r_\lambda$, for all routers $r$ in the 
same domain as $r_\lambda$,
if 
$\Theta(r) = \Theta(r_\lambda)$, we have that $G(\Theta(r), \lambda) = \{r_\lambda\}$.
If $\lambda$ is not connected
to any router in the domain as $r$, then $G(\Theta(r),\lambda)$ is 
determined by the BGP configuration, which we will talk about later. 


We now define the OSPF routing function $\route_{ospf}: 
V \times \Lambda \mapsto 2^V$ so that
$\route_{ospf}(r,\lambda)$
 describes the next-hop for
router $r$ when forwarding traffic for a destination $\lambda$. 
If $\lambda$ is directly connected to a router $r_\lambda$ in the same OSPF domain as 
$r$---i.e., $G(\Theta(r),\lambda) = \{r_\lambda\}$---then 
the OSPF router $r$ will forward traffic directed to $\lambda$ along a path with
shortest distance to router $r_\lambda$. This is expressed as follows. 
\[
\route_{ospf}(r,\lambda) = \{r_1 ~|~ r_1 \in N(r)\wedge \forall r_2 \in N(s) .~W(r, r_1) + D(r_1, r_\lambda) \le 
W(r, r_2) + D(r_2, r_\lambda)\}
\]

\minisection{BGP} BGP is a path-vector inter-domain routing protocol
that connects different domains (also called autonomous systems), where each domain
comprises of one or more routers typically managed by a single
entity. A BGP router receives routes from BGP peers: internal peers
send iBGP routes, external peers send eBGP routes. Each route for 
a certain
destination comprises of a domain-level path to the destination
domain and, by default, a BGP router will forward a packet through the path that traverses fewer domains.
BGP routers can be configured with a
\emph{local preference} to assign higher priorities to
specific routes for a 
particular destination. We define the local
preference function $LP: V \times V \times \Lambda \mapsto \nat$ as
follows.  Given a BGP router $r$, a neighbouring router $r'$, and  
a destination $\lambda$, $LP(r, r', \lambda)$ specifies the local
preference for the router $r$ to choose $r'$ as the next-hop router for destination $\lambda$.  This function is only defined
on inter-domain links---i.e., $r$ and $r'$ must belong to adjacent domains.  
From the routes received at $r$, the router
picks one with greatest local preference.

The Internal BGP (iBGP) protocol is used to 
exchange external BGP routes 
among BGP routers belonging
to the same domain. Informally, iBGP propagates local preferences of the routes to all the BGP routers within the same domain. 
We can configure iBGP 
filters to prevent a router from advertising 
a route to another router. We do so using the 
function $IF: V \times \Lambda \mapsto 2^V$
such that,
if a BGP router $r_1$ belongs to  $IF(r_2, \lambda)$, then
the router $r_2$ will not advertise a route for $\lambda$ to
$r_1$ through iBGP. 
\input{bgp-routing-algorithm} 
 
Algorithm~\ref{alg:bgppathrules} defines the BGP routing function
based on the best path selection at each BGP router. 
%a local preference function $LP$,
Informally, BGP 
chooses a route with highest local preference, and
if there is a tie, it chooses the route that traverses fewer domains~\cite{bgp}. 
We assume all ties 
are broken using these criteria. 
Formally, we define a partial BGP routing function 
$\route_{bgp}: V \times \lambda \mapsto V$
so that
$\route_{bgp}(r,\lambda)$
 describes the next-hop BGP router for
 the BGP
router $r$ when forwarding traffic for a destination $\lambda$. 

\minisection{OSPF+BGP+SR} We now describe how routing
happens in hierarchical networks with all the previously described protocols
used together.
We express the complete network configuration $C$
as a tuple $(T, \Theta,W,LP,IF,SR)$, where $T$ is the 
network topology, $\Theta$ is
the router domain assignment, $W$ is the OSPF
edge weight function,
$LP$  is the local preference function for BGP,
$IF$  is 
 the iBGP filter function, and 
 $SR$ is the static route
function.  

We now define the routing function 
$\route^C: V \times \Lambda \mapsto 2^V$ 
so that
$\route^C(r,\lambda)$
 describes the next-hop router for
 the 
router $r$ when forwarding traffic for a destination $\lambda$. 
At a router $r$, if there exists 
static routes for destination $\lambda$,
these routes take highest precedence over OSPF and BGP routes, 
and thus $\route^C(s, \lambda) = SR(s, \lambda)$.
For a domain $\theta$, if $\lambda$ is not directly 
connected to one of the routers in $\theta$, the BGP 
gateways will receive external advertisements for $\lambda$.
For this scenario, the gateway router set is defined 
$G(\theta, \lambda) = \{r \mid \route^C_{bgp}(r, \lambda) \not= \perp\}$
Consider a router $r$ in domain $\theta$. 
If router $r$ is a BGP router belonging to $\theta$ and $r \in G (\theta, \lambda)$, then the external BGP route has higher
precedence over any OSPF route and thus $\route^C(r, \lambda)=\route^C_{bgp}(r, \lambda)$. 

Finally, for a router $r$ in $\theta$ which is not a BGP gateway 
router and that has no static routes, $r$ uses OSPF to route traffic to the closest BGP
gateway router in $G (\theta, \lambda)$, which in turn will forward  the traffic to its neighbouring domains and so on till it reaches the internal domain of $\lambda$.  Thus, the modified OSPF routing 
function $\route^C_{ospf}$ for an external destination $\lambda$
is defined as follows: 
\begin{multline*}
\route_{ospf}^C(r,\lambda) = \{~~r_1 \mid r_1 \in N(r) \wedge \exists g_1 \in G (\theta, \lambda). ~\forall r_2 \in N(s), g_2 \in G (\theta, \lambda). \\ ~W(r, r_1) + D(r_1, g_1) \leq
W(r, r_2) + D(r_2, g_2)\}
\end{multline*}
Piecing together the different routing protocols and their 
interactions, the routing function 
$\route^C$ for the hierarchical domain network configuration $C$ is defined as follows: 
\[
\route^C(r, \lambda) = 
\begin{cases}
SR(r, \lambda) & \text{if } SR(r, \lambda) \not= \emptyset, \\
\route_{bgp}^C(r, \lambda) & \text{if }r \in G(\Theta(r), \lambda), \\
\route_{ospf}^C(r, \lambda) & \text{otherwise.} 
\end{cases}
\]
%\[
%\begin{array}{c}
%	\route^C(s_1, t, \lambda) = 
%	\route_{ospf}^C(s_1,g_1, \lambda) + 
%	 (g_1, s_2 )+\qquad\qquad\qquad  \\
%%	~~~~~~~~~~~~~~~~~~~~~~~~~\route_{ospf}^C(s_2,g_2, \lambda) + (g_2, s_3) + \\
%	\qquad\qquad\qquad\qquad \cdots  + (g_{n-1}, s_n) +\route_{ospf}^C(s_n,t,\lambda)
%\end{array}
%\]

\minisection{Induced paths}
In the following, we assume a finite set of packet classes $PC = \{0, \ldots, C_{pc}\}$ 
and map each reachability
policy that requires the existanence of a path between two endpoints
to a unique integer in $PC$. The rest of the policies specify 
properties on these paths. Each packet class $pc$ is associated
with a tuple ($s_{pc}, d_{pc}, \lambda_{pc})$ which specifies 
the path from $s_{pc}$ to $d_{pc}$ for destination IP $\lambda_{pc}$.

\begin{definition}[Induced Paths] \label{def:inducedpaths}
Given a configuration $C$, the set of paths induced
by the configuration $C$ for the packet class $pc$ is defined as follows:
\[
\paths^C(pc) = \{\pi=(u_1, v_1)\ldots (u_n, v_n) \mid 
valid(\pi) \wedge 
u_1 = s_{pc} \wedge v_n= d_{pc} \wedge
\forall i. ~v_i \in \route^C(u_i,\lambda_{pc})\}
\]
Given a set of packet classes $PC$, the set of paths
 induced by $C$ is defined as
$\paths^C(PC) = \cup_{pc\in PC} \paths^C(pc)$.
\end{definition}

\subsection{Policy Support}

One of the foremost tasks in network management in enterprise 
and multi-tenant datacenters\footnote{
In a multi-tenant datacenter, different entities ("tenants") share the datacenter's 
infrastructure (compute, network etc.).
} 
is programming 
networks to forward traffic in a manner consistent with user- and
application-induced high-level policies for performance and security considerations. 
Unlike SDN, ``traditional'' networks are  heterogeneous and run different kinds of 
protocols, and thus, operators require support to enforce and/or optimize different
configuration structure and properties. 
We classify Zeppelin's policy support into two categories: 
(1) \emph{path policies}: high-level intents on paths of different traffic classes, and 
(2) \emph{configuration policies}: low-level intents on the deployed router configurations. 

\input{policy}
\Cref{tab:policysupport} describes 
the common path policies 
supported by \name, particularly suited for operators 
of a multi-tenant datacenter. 
In our tool, operators can
specify policies in a declarative manner using a high-level 
policy language. 
Given  a set $\Psi$ of
path policies, we say that
a set of paths $\Pi$ is policy-compliant with respect to $\Psi$, 
denoted  $\Pi \models \Psi$,
if the paths in $\Pi$ satisfy all the policies in $\Psi$ (see~\cite{genesis} for the formal definition). 


\minisection{Reachability and Waypoints}
This policy enables network communication
between pairs of an tenant entity's virtual instances (VM), 
applications, or hosts.  
The tenant may wish that the flow
between two of her end hosts, or from another tenant, must traverse
specific middleboxes, which we also refer to as ``waypoints'' in
this paper. Middleboxes are custom processing appliances often used
for security, access control, or performance reasons (e.g.,
firewalls, intrusion prevention systems, monitoring/accounting
gateways, proxies, and load balancers). Note that, \name 
primarily supports routing policies for traffic allowed in the network.
For access control policies of the form "host A cannot talk to B", operators
can use host-based or hypervisor-based firewall rules  
to disallow traffic blocked by policies. Supporting access control policies 
in configurations is a subject for future work.    

\minisection{Isolation} Tenants may require various
Quality-of-Service (QoS) or security guarantees since the 
underlying infrastructure is shared among tenants. In the extreme, a
tenant could require that her flows are not affected in any manner
by any other tenant by strictly isolating the path of the tenant's
flows from others' flows. 

\minisection{Traffic Engineering}
While support for the above policies can be used to satisfy tenant 
requirements, network operators need to 
carefully manage constrained resources. Operators may also want
to balance load on their network infrastructure. This is often done
by optimizing a network-wide objective such as total or maximum
utilization of network links due to traffic induced by all tenants. 

The high-level path policies are enforced by different low-level 
configuration constructs pertaining to routing protocols like OSPF and BGP, 
and ideally, the operator requires support to impose constraints on the structure 
and properties of the deployed configurations. 
\Cref{tab:configpolicysupport} 
describes all the configuration policies supported by \name for hierarchical 
control planes. 
A configuration $C$ satisfies a set of configuration policies $P$
if $C$ satisfies every constraint in $P$.
For each configuration policy 
we define what it means for  a configuration $C=(T,\Theta,W,LP,IF,SR)$ to satisfy it.

\input{zeppelinPolicy}
\minisection{OSPF Domains and Sizes}
The first type of policy restricts how many OSPF domains $N_D= |\{\Theta(r)\mid r\in V\}|$ a
configuration might have
and it is satisfied by $C$ iff $c_1\leq N_D \leq
c_2$.  This policy is useful for avoiding situations resulting in too
many domains in the hierarchical split which can be difficult to
administer.  The second type of policy allows the operator to restrict
the size $ds=|\{r \mid \Theta(r)=i\}|$ of each OSPF domain, $l\leq ds\leq u$, because OSPF does
not scale gracefully with network size.  


\minisection{Resource Constraints} Certain 
	routers may not be suited to run BGP due to resource
	constraints. Thus, the operator can specify what set of 
	routers $B\subseteq V$ is BGP-compatible.  
	This policy is satisfied if none of the routers $V\setminus B$
	is a gateway router.
	Formally, for every $r\in V\setminus B$,
	there does not exist a router $r'\in N(r)$ such that $\Theta(r) \not= \Theta(r')$

\minisection{Configuration Metrics}
Finally, \name provides ways to specify upper bounds on the number of
static routes---i.e., $sc=|\{(v, v', \lambda)\mid \exists v'. v' \in SR(v,\lambda)\}|\leq C_{sc}$--- and
BGP configurations---i.e., 
$bc=|\bigcup_{v,\lambda\in V\times\Lambda} IF(v,\lambda)\cup \{(v,v',\lambda)\mid LP(v,v',\lambda)$ $\neq \bot\}|\leq C_{bc}$.
While static routes are a powerful too, it is desirable to limit the number of static routes used since they
can lead to undesired routing behaviors such as routing loops (more in~\secref{sec:loopavoidance}). Similarly, it is desirabel to limit the number of BGP configurations
since they increase the complexity of the network.
\name can  also try to minimize certain expressions over the quantities $sc$, and $bc$---e.g., $max(sc, bc)$. 

\subsection{Synthesis of policy-compliant configurations}
We now define when a configuration $C$ is policy-compliant, present our synthesis problems, and introduce two definition of resilience we will use throughout the paper.
\begin{definition}[Policy-Compliance and Synthesis] \label{def:policycompliance}
	Given a set of path policies $\Psi$ and a set of configuration policies $P$,
	a configuration $C$ is policy-compliant with $(\Psi,P)$,  
	written as $C \models (\Psi,P)$, if the set of
	induced paths satisfies $\Psi$---i.e., $\paths^C(PC) \models \Psi$---and $C$ satisfies the policies in $P$.
	The \emph{configuration synthesis problem} is to find, given $\Psi$ and $P$,
a configuration $C$ that is policy compliant with $(\Psi,P)$.
\end{definition}

Our approach will proceed in two phases,
one of which solves the following sub-problem.  
\begin{definition}[Path-Compliance and Synthesis] \label{def:pathcompliance}
Given configuration policies $P$
and a set of paths $\Pi$ over packet classes $PC$,
	a configurations $C$ is path-compliant with 
	$(\Pi,P)$,
	if $\paths^C(PC)=\Pi$ and $C$ satisfies the policies in $P$.
	The \emph{path-compliance synthesis problem} is to find, given $P$ and $\Pi$,
a configuration $C$ that is path-compliant with $(\Pi,P)$.
\end{definition}

\minisection{1-Resilience metrics}
One of the main goals of this paper is to 
generate configurations that are highly resilient to failures. In this
work, we focus on resilient configurations for single link failures. 
For a packet class $pc$ and configuration $C$, we define 
the set of links \emph{affecting} $pc$ as 
$\links(pc) = \{l \mid \exists \pi \in \paths^C(pc).~l \in \pi  \}$.
For a single failure of a link $l$, a packet class $pc$ is affected 
if only if $l \in \links(pc)$. 
Given a configuration
$C=((V,L), \Theta,W,LP,IF,SR)$ and a link $l\in L$,
we write $C_l$ 
to denote the configuration
$C=((V,L\setminus\{l\}), \Theta,W,LP,IF,SR)$
in which the link $l$ has been removed from the topology.
We present two different resilience metrics 
we will use in the following sections. 

The first metric describes how good a given configuration
is at preserving policy-compliance under an 
arbitrary single link failure. 
The score measures, for each policy $pc$, what percentage of the links affecting $pc$
causes a policy to still hold when failing.
\begin{definition}
The \emph{policy-resilience} score of a configuration 
$C=((V,L), \Theta,W,LP,IF,SR)$
is defined as:
\[
PR(C)=\frac{\sum_{\forall pc} |\{ l \mid l \in \links(pc) ~\wedge~ C_l \models (\Psi_{pc}, P) \}|}
{\sum_{\forall pc} |\links(pc)|}
\]
where $C \models (\Psi_{pc}, P)$ means that $C$ is 
compliant for the set of policies $\Psi_{pc}$ that affect packet class $pc$.
\end{definition}

In general, generating configurations with high policy-resilience is hard,
since there may be only a few paths that satisfy a certain policy.
Therefore, we also consider a second 
more relaxed metric, which describes how 
good a given configuration
is at preserving connectivity
(but not policy compliance) upon a single link failure. 
\begin{definition}
The \emph{connectivity-resilience} 
score of a configuration $C=((V,L), \Theta,W,LP,IF,SR)$
is defined as follows:
\[
CR(C)=\frac{\sum_{\forall pc} |\{ l \mid l \in \links(pc) ~\wedge~\paths^{C_l }(pc) \not= \emptyset  \}|}
{\sum_{\forall pc} |\links(pc)|}
\]
\end{definition}
 
Ideally, operators desire a resilience score of 1 (perfectly resilient for policy-compliance or
preserving connectivity). However, achieving this objective is in practice difficult  
due to the 
increased number of configurations one needs to consider,
and sometimes impossible due to the structure of the network and the nature of policies.
In practice, \name can synthesize configurations 
with high resilience scores and operators can run it to generate different configurations until
a threshold score is crossed. 
%\todo{write resilience metrics here and some text like the following.}
%\kausik{Ideally, the most important metric we want to maximize is resilience---i.e.,
%the number of alternate paths between endpoints.
%However, this metric is too hard to handle as it depends on complex graph properties. 
%In practice, when we want improve resilience, we try to minimize
%the number of filters; we will show that this strategy is effective in our experiments. }

