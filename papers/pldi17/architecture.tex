\section{Architecture} \label{sec:architecture}
\loris{In this section, we ...}
Mitigating complexity of Policies to configurations
by going through policies to paths (\genesis) and
paths to configurations (\name)

The drawback of this approach is that one might need to consider multiple possible
data planes before finding one that can successfully complete all the phases of the
synthesis algorithm

\subsection{\genesis: From Policies to Paths} \label{sec:genesis}
The first phase of our approach produces a set of paths adhering to
different policies using \genesis~\cite{genesis}, a network management
system which synthesizes forwarding tables enforcing the policies. 
Some of the policies supported by \genesis are specified in 
\Cref{tab:policysupport}. 

Many of the policies supported by \genesis have high 
theoretical complexity (e.g., isolation); \genesis 
leverages fast off-the-shelf SMT solvers to provide
support for policy enforcement for a diverse set of policies.
Given a set of policies, \genesis generates a set of constraints 
over propositional logic (SAT) and Linear rational arithmetic (LRA),
such that the solutions to these constraints are forwarding
tables, which can be used to extract the 
policy-compliant paths.

\paragraph{Modifications from~\cite{genesis}}
OpenFlow switches~\cite{openflow} support match predicates for
forwarding rules on different packet header fields like source
and/or destination IP address, ports etc. However, legacy protocols
like OSPF and BGP only support destination-based forwarding, 
forcing the paths to a destination subnet to 
form a directed tree rooted at the destination. 
Thus,
at any router, there exists atmost one forwarding rule for a 
particular destination. However, since \genesis was built for
SDN management, paths synthesized for a destination subnet may
diverge at a switch, and thus cannot be induced by any router
configuration. 

Thus, we modify \genesis to add constraints to ensure that
if any two paths to a destination subnet intersect at a router,
the subsequent downstream paths to the destination from the
router do not \emph{diverge} at a router.  
We define the relation $Reach^*(sw,pc)$ to model reachability 
of $sw$ in the path of $pc$, i.e., it can be reached in zero or more
steps from the source. We can be expressed $Reach^*(sw,pc)$ 
in the network forwarding model of \genesis as:
\begin{equation}
	Reach^*(sw,pc) = \bigvee_{k \in [0, \mu]} Reach(sw, pc, k)
\end{equation}
$\mu$ denotes the synthetic limit of the length of the path. 
$Reach(sw, pc, k)$ is valid if $sw$ is reachable in the path of
class $pc$ in $k$ steps. Thus, to enforce the destination-based
forwarding using $Reach^*(sw,pc)$, we add
constraints for every pair ($pc_1$,$pc_2$) having the same 
 destination subnet:
 \begin{multline}
 \forall sw. Reach^*(sw, pc_1) \wedge Reach^*(sw, pc_2) \implies \\ \bigvee_{n \in N(sw)} Fwd(sw, n, pc_1) \wedge Fwd(sw, n, pc_2)
 \end{multline}
 $Fwd(sw_1, sw_2,pc)$ is valid if $sw_1$ forwards $pc$ to next-hop $sw_2$ and
 $N(sw)$ denotes the neighbours of $sw$. Basically, 
 if a switch is reachable for both packet classes, 
 then the next switch must be the same for both classes
 (paths will not diverge), and thus, the paths obtained
 from \genesis for a destination subnet will form a 
 directed destination tree. 

\subsection{\name: From Paths to Router Configurations} 
\loris{you also need to talk about the second part of the architecture briefly.}
