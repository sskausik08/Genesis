\section{Architecture} \label{sec:architecture}
In this section, we describe the architecture of our system.
Since directly generating policy-compliant configurations
is a challenging problem, we use a two-phase approach in which
we first synthesize policy-compliant \emph{paths}
using the tool \genesis~\cite{genesis} and then present
a new tool, \name, that synthesises configuration that produce the
paths we synthesized in the first phase. 
Since the first phase may produce \emph{bad} paths for which the
configuration synthesis is complicated or not possible,
we then propose ways to restart the algorithm by computing new paths.

\subsection{\genesis: From Policies to Paths} \label{sec:genesis}
The first phase of our approach produces a set of paths adhering to
different policies using \genesis~\cite{genesis}, a network management
system which synthesizes forwarding tables enforcing the policies. 
Some of the policies supported by \genesis are specified in 
\Cref{tab:policysupport}. 
Due to the rich policy language, generating policy-compliant paths is an NP-complete problem;
\genesis leverages fast off-the-shelf SMT solvers to provide
support for policy enforcement for a diverse set of policies.
Given a set of policies, \genesis generates a set of constraints 
over propositional logic (SAT) and Linear rational arithmetic (LRA),
such that the solutions to these constraints are forwarding
tables, which can be used to extract the 
policy-compliant paths.

\loris{two sentences about what \genesis currently does, 
generates constraints over Reach and Fwd and briefly mention meaning
of a solution}

\paragraph{Modifications from~\cite{genesis}}
In this section, we discuss how \genesis
constraints need to be modified to avoid generating paths that 
cannot be enforced by any routing configuration.

OpenFlow switches~\cite{openflow} support match predicates for
forwarding rules on different packet header fields like source
and/or destination IP address, ports etc. However, legacy protocols
like OSPF and BGP only support destination-based forwarding, 
forcing the paths to a destination subnet to 
form a directed tree rooted at the destination. 
Thus,
at any router, there exists at most one forwarding rule per destination. 
Since \genesis was built for
SDN management,  a switch may forward to different switches
packets that are directed to the same destination,
and thus cannot be induced by any router
configuration. 

We add constraints to \genesis to ensure that
if any two paths to a destination subnet intersect at a router,
the subsequent downstream paths to the destination from the
router do not \emph{diverge} at a router.  
\loris{assuming you have defined Reach and Fwd at 
earlier where I put comment}
We define the relation $Reach^*(sw,pc)$ to model reachability 
of $sw$ in the path of $pc$, i.e., it can be reached in zero or more
steps from the source. We can be expressed $Reach^*(sw,pc)$ 
in the network forwarding model of \genesis as:
\begin{equation}
	Reach^*(sw,pc) = \bigvee_{k \in [0, \mu]} Reach(sw, pc, k)
\end{equation}
$\mu$ denotes the synthetic limit of the length of the path. 
$Reach(sw, pc, k)$ is valid if $sw$ is reachable in the path of
class $pc$ in $k$ steps. Thus, to enforce the destination-based
forwarding using $Reach^*(sw,pc)$, we add
constraints for every pair ($pc_1$,$pc_2$) having the same 
 destination subnet:
 \begin{multline}
 \forall sw. Reach^*(sw, pc_1) \wedge Reach^*(sw, pc_2) \implies \\ \bigvee_{n \in N(sw)} Fwd(sw, n, pc_1) \wedge Fwd(sw, n, pc_2)
 \end{multline}
 $Fwd(sw_1, sw_2,pc)$ is valid if $sw_1$ forwards $pc$ to next-hop $sw_2$ and
 $N(sw)$ denotes the neighbours of $sw$. Basically, 
 if a switch is reachable for both packet classes, 
 then the next switch must be the same for both classes
 (paths will not diverge), and thus, the paths obtained
 from \genesis for a destination subnet will form a 
 directed destination tree. 

\subsection{\name: From Paths to Router Configurations} 
After we have computed a set of policy-compliant paths,
we need to solve the path-compliance problem using such paths.
To solve this problem, we propose the tool \name, which
combines techniques in constraint solving and randomized search
to efficiently generate router configurations for the paths obtained from \genesis.
For a given domain division of the network,
\name uses linear constraints to generate OSPF weights and BGP preferences.
If the constraints fail, \name uses the unsatisfiable cores to
identify where to place route-filters.
To decide how to split the network into domains,
\name uses Markov Chain Monte Carlo (MCMC) search to find
domain assignments that satisfy the configuration policies and have good resilience.
When the MCMC search does not progress and cannot find good solutions,
we restart the search by asking \genesis to generate a new set of paths.
These techniques are described in detail in the next two sections.
