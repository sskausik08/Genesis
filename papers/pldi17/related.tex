\section{Related Work}\label{sec:related}
\minisection{Centralized control} Programming routers for centralized
control has been an active area of research in recent times. One of
the first systems, RCP~\cite{rcp}, supported logically central BGP
configuration. The more recent Fibbing~\cite{fibbing} system provides
centralized control over distributed routing by creating fake nodes
and fake links to steer the traffic in the network through paths that
are not the shortest. However, these fake advertisements can create
forwarding loops in the network during failures, and the centralized
controller has to respond to failures (response to failures can
precomputed), thus making the controller a central point of
failure. In contrast, our approach to distributed control plane
synthesis can provide the same expressive power as Fibbing but avoids
any centralized component by engineering the control plane parameters
to match the input specifications.  Fibbing also does not take into
account inter-domain routing.

\minisection{Configuration synthesis} ConfigAssure~\cite{configassure}
uses a combination of logic programming and SAT solving to synthesize
network configurations for security, connectivity, performance and
reliability requirements specified as constraints; but it does not
support resilience or hierarchical domain splitting.  Fortz
et. al~\cite{ospf-te} tackle the problem of optimizing OSPF weights
for performing traffic engineering, but their work is tailor-made
to just this specific problem.

Propane~\cite{propane} tackles the specific problem of synthesizing
BGP configurations to ensure network-wide objectives hold even under
failures. The policy language of Propane is suited to specify
preferences on paths and peering policies among different autonomous
systems, but it does not support fine-grained policies over paths---e.g.,  isolation and traffic engineering. Propane translates policies
to a graph-based intermediate representation, which is then compiled
to device-level BGP configurations. It is unclear how to extend
Propane to incorporate domains, configuration complexity, or OSPF.

El-Hassany et. al~\cite{synet} tackle network-wide configuration
synthesis (\Cref{def:policycompliance}) in an elegant manner by
modeling the behavior and interactions of the routing protocols as a
stratified Datalog program, and using SMT to synthesize the Datalog
input such that the fixed point of the Datalog program (which
represents the network's forwarding state after the protocols have
converged) satisfies certain policies.  An earlier iteration of our
work considered synthesizing network configurations directly from
policies using SMT; however, we found that encoding OSPF's shortest
path-based constraints in SMT was time-consuming for modern SMT
solvers~\cite{z3} and does not scale well to larger networks (the
largest topology considered by El-Hassany et. al is 16). Instead, we
split the problem by synthesizing policy-compliant paths, and can use
LP-solvers (which are faster and parallelizable) to tackle OSPF
synthesis.  Their policy language does not support isolation or
traffic engineering, and they do not model OSPF route filters, which
are a source of NP-completeness.  They also perform synthesis for a
static domain assignment, where the input specifies if a router runs
BGP or not.

\minisection{Policy languages}
Other works on centralized policy enforcement 
for SDN are Merlin~\cite{merlin} and NetKAT~\cite{netkat}.  
In Merlin, data planes that adhere to policies
expressed using regular expressions are synthesized by first
intersecting the topology with the regular expressions appearing in
the policies and then encoding reachability in the intersected graph
using mixed integer linear programming (ILP).
Merlin supports minimum and maximum bandwidth guarantees.

NetKAT is a domain-specific language and logic for 
specifying and verifying network packet-processing functions
for SDN, based on Kleene algebra with tests (KAT). Semantically,
a NetKAT predicate and policy is a function that takes a packet
history and produces a set of (possibly empty) packet histories. 
NetKAT can be used to express certain network-wide policies like 
reachability, waypoints using regular expressions for describing the paths, 
and programs on virtual topologies; it uses
BDDs and symbolic automata to translate global programs to local
switch programs~\cite{netkatcompiler}. 
However, the NetKAT semantics
cannot be used to express policies based on hyperproperties
~\cite{hyperproperties}, i.e., 
the packet processing function requires multiple packet histories
as input. Traffic engineering or isolated paths are policies
based on hyperproperties. 

%Fine-grained traffic engineering based on online demand/flow size estimation and 
%rapid rerouting is also crucial for datacenter workloads, and extending \name's
%TE policies to fine-grained timescales is subject of future work.
%Also, the performance
%of SMT solvers with optimization objectives is quite slow, and calls for 
%domain-specific techniques to speed up the synthesis. Also, datacenter
%networks are highly symmetrical, and this symmetry can be leveraged
%to speed up synthesis (similar to the work of Plotkin et. al~\cite{symmetry} to
%speed up network verification using symmetry). The main challenges of
%using symmetry in synthesis is considering two aspects of symmetry: network
%symmetry and policy symmetry. Also, our treatment of resilience synthesis
%is preliminary and future work will be geared towards synthesizing resilient
%forwarding planes incorporating capacity constraints and traffic engineering.
 
