\section{Routing Model and Problem Definition}
\loris{in several places we use $r\rightarrow r'$ for paths which makes it confusing with normal implication.
I would replace them all with $r\cdots r'$.}

In this section, we formally define the problem addressed in this
paper.  We first define common notations and then show how different
routing protocols are represented.  In particular, we model static
routes, OSPF shortest-path routing, and BGP preference-based routing.
Finally, we formally define when a certain configuration meets a given
set of policies and conclude with the configuration synthesis problems
we tackle.

\subsection{Routing Model}

\minisection{Preliminaries}
We represent the physical router topology as a directed graph $T=(V, L)$,
where $V$ is the set of routers and $L\subseteq V\times V$ is the set of links. 
We use the neighbour function $N(s) = \{s'\ | \ (s,s') \in L \}$ to denote 
the set of neighbour routers of $s$. 
We define $\Lambda$ to denote the set of destination IP subnets;
distributed protocols make forwarding decisions based on the 
destination IP address/subnet.

A path $\pi = (u_1,v_1) (u_2, v_2) \ldots (u_n, v_n) \in L^*$ is a loop-free valid path if
a  vertex is not visited more than once ($\forall i.j \leq n. 
~i \not= j \wedge u_i \not= u_j$) and adjacent links in the
path share a router ($\forall i < n. ~v_i = u_{i+1}$).
Given two nodes $s$ and $t$, we use $\Pi_s^t$ to denote the set of all paths
$\pi$ with source $s$ (i.e., $u_1=s$) and target $t$ (i.e., $v_n=t$). 
We also define the $\in$ operator for paths i.e., a link $l \in
\pi$ if $l$ is in the path. 

\name tackles the synthesis of a hierarchical control plane, 
where the network is divided into continuous domains. 
Each domain uses OSPF as the intra-domain routing protocol, 
and BGP for the inter-domain routing protocol. 
We define a router domain assignment function
$\Theta: V \rightarrow \nat$ which maps each router to a domain 
(denoted by a natural number).

The OSPF configurations are expressed 
using two functions: edge weights $W$ and
route-filters $RF$. For BGP configurations: 
we have the local preference function $LP$ 
and the iBGP filter function $IBF$. Static 
routes are expressed using the $SR$ function.
We express the complete network configuration $C$
as a tuple $(T,\Theta,W,RF,LP,IBF,SR)$.  In the 
rest of the section, we describe each component 
of the configuration $C$ and the routing function 
$\route^C$ for the network given $C$. We ensure one  
simplifying property for $C$: for two 
routers $r_1$ and $r_2$ in the network,
traffic will be forwarded from $r_1$ to $r_2$ 
along a single path. 
Thus, when synthesizing $C$, we ensure the components
of $C$ satisfy this property.


\minisection{Static Routes} Static routing refers to a router using a
manually-configured routing entry, rather than information from
dynamic protocols like OSPF or BGP.  It is useful to enforce certain
paths that are not easily realizable using routing protocols.  Static
routes have the highest preference over other routes for the same
destination at a router.  For a destination $\lambda$, a static route
configured at router $r$ ensures the traffic to forward to a
neighbouring router $r_1 \in N(r)$. We define the static route partial
function $SR: V \times \Lambda \mapsto V$ such that, for a router $r$
and destination $\lambda$, if $SR(r,\lambda)=r'$, then traffic for
destination $\lambda$ reaching node $r$ is always forwarded to node
$r'$.  \loris{might want to say how you construct it and that we
  assume SR is well formed, i.e., things form paths.}  Using $SR$, we
construct the complete static paths between routers in the network
$\Pi_{SR}$.

%These paths would have a highest preference.

\minisection{OSPF} Open Shortest Path First (OSPF) is a routing
protocol commonly used inside a domain. Each router receives link
state information from other routers and uses this to create a map of
the network. Positive weights are defined for each link in the
network, and each router used Djikstra's algorithm to forward to the
destination along the weighted shortest path to the router the
destination IP is connected to.

Let us
define the OSPF weight function $W: L \rightarrow \rat$ which 
maps edges of the topology to positive rational weights. 
% todo: When to talk about converting LRA to LIA.
For a given
path $\pi=l_1\ldots l_n$, we indicate the sum of weights of the
links in the path by $w(\pi)=\sum l_i$. 


We allow route-filters
to selectively disable an
edge for a given destination by  
blocking advertisements to a
particular destination along a link. 
Formally, a route-filter is a pair $(l,\lambda)\in L\times \Lambda$
which disables the link $l$ for destination $\lambda$. 
We define the route-filter function 
$RF: \Lambda \rightarrow 2^L$ which maps each destination IP
to a set of filtered links in the topology. 
Given an IP destination $\lambda\in \Lambda$, 
a legal path with respect to $RF$ and $\lambda$
is a valid path $\pi=l_1\cdots l_k$ such that for every $i$,
$l_i\not\in RF(\lambda)$.
We use $\Pi_\lambda$ to denote the set of all such paths.

We define the routing function 
$\route_{ospf}^G$ 
that given 
%a weight function $W$,
%a route-filter function $RF$,
a source node $s$,
a target node $t$,
and destination IP 
$\lambda$,
returns the OSPF-induced paths from $s$ to $t$ for destination IP $\lambda$.
The paths between two nodes are
the shortest paths in the network
that do not cross any link that belongs to $RF(\lambda)$. We also
account for the higher priority of static routes.
\begin{multline} \label{eq:ospfmodel}
\route_{ospf}^C(s,t,\lambda) = \\
\begin{cases}
\text{$\Pi_s^t \cap \Pi_{SR}$}  & \text{if $\Pi_s^t \cap \Pi_{SR} \not=\emptyset$} \\
\text{$\{\pi \mid  \pi\in \Pi_s^t\cap \Pi_\lambda ~\wedge $} & \\
\text{~~~~$\neg\exists \pi'\in\Pi_s^t\cap \Pi_\lambda . w(\pi')< w(\pi)\}$} & \text{otherwise}
\end{cases}
\end{multline}

\minisection{BGP} BGP is a path-vector inter-domain routing protocol
that connects different autonomous systems (ASes), where each AS
comprises of one or more routers (typically managed by a single
entity). A BGP router receives routes from BGP peers (internal peers
send iBGP routes, external peers send eBGP routes). Each route for the
destination comprises of a domain-level path to the destination
domain, and by default a BGP router will pick a path with fewest domains 
to forward the packet for a destination.
 
To support policy routing, BGP routers can be configured with a
\emph{local preference} variable to assign higher priorities to
specific routes for a particular destination. We define the local
preference function $LP: V \times V \times \Lambda \mapsto \nat$ as
follows.  Given a BGP router $r$, neighbouring router $r_1$, and IP
destination $\lambda$, $LP(r, r_1, \lambda)$ specifies the local
preference for a route received for destination $\lambda$ at BGP
router $r$ from next-hop BGP router $r_1$.  This function is defined
on inter-domain links.  From the routes received at $r$, the router
picks the route with greatest local preference.

The Internal BGP (iBGP) protocol is used to 
exchange external BGP routes 
among BGP routers belonging
to the same domain. A external route received 
by $r_1$ with a local preference value configured 
will be advertised to the rest of the BGP routers of the 
domain as an iBGP route with the same local
preference. We can configure iBGP 
filters to prevent a router from advertising 
a route to another router. We define the 
function $IBF: V \times \Lambda \mapsto 2^V$. 
If a BGP router $r_1 \in IBF(r_2, \lambda)$, then
$r_2$ will not advertise a route for $\lambda$ to
$r_1$ through iBGP. 
 
Algorithm~\ref{alg:bgppathrules} defines the routing function 
$\route_{bgp}^C$ 
that given 
%a local preference function $LP$,
a BGP router $r$
and destination  
$\lambda$,
returns 
the next-hop BGP router in the path. BGP 
chooses a route with highest local preference, and
if there is a tie, it then chooses the route with smallest
AS path length~\cite{bgp}. While, the actual implementation
of BGP uses several other criteria,
\name uses these rules to synthesize BGP configurations with 
ordering maintained with respect to actual BGP implementations.
We ensure all ties are broken, and $\route_{bgp}^C(r,\lambda)$
returns a single router. Also, static routes 
have a higher preference than BGP, therefore a static route
$SR(r, \lambda)$ will be preferred over the BGP route.

\begin{algorithm} [t]
	\begin{footnotesize} 
		\caption{BGP Best Path Selection at router $r$ for dst. $\lambda$}
		\label{alg:bgppathrules}
		\begin{algorithmic}[1]
			\Procedure{BestPath}{} \\
			\hspace*{0.4cm} [Each route $\gamma$ of form $(\lambda, local\_pref, len, nexthop)$]
			\State{$\Upsilon_{ebgp}$ = $\bigcup$ Route from external BGP neighbour for $\lambda$} 
			\State{$\Upsilon_{ibgp}$ = $\bigcup$ Route from internal BGP router $r_1$:
				 $r \not\in IBF(r_1, \lambda)$}
			\State{$\Upsilon = \Upsilon_{ebgp}\cup \Upsilon_{ibgp}$}
			\\
			\If{$SR(r,\lambda) = r_1$} 
			\State{$\route^C_{bgp}(r, \lambda) = r_1$\hfill [Static Route has highest pref.]}
			\Else \\
			\indent\indent \hspace{0.3cm}[Find routes with highest \emph{local preference}]
			\State{$\Upsilon_{lp} = \{\gamma \in \Upsilon \mid \forall \gamma_1 \in \Upsilon. ~\gamma.local\_pref \geq \gamma_1.local\_pref\}$}
			\If{$|\Upsilon_{lp}| = 1$}
			\State{$\gamma_{best} = \gamma \in \Upsilon_{lp}$}
			\Else \newline
			\hspace*{0.7cm}\indent [Prefer the path with the smallest \emph{AS Path length}]
			\State{$\Upsilon_{as} = \{\gamma \in \Upsilon_{lp}  \mid \forall \gamma_1 \in \Upsilon_{lp}. ~\gamma.len \leq \gamma_1.len\} $}
			\If{$|\Upsilon_{as}| = 1$}
			\State{$\gamma_{best} = \gamma \in \Upsilon_{as}$}	
			\EndIf
			\EndIf
			\If{$\gamma_{best} \in \Upsilon_{ebgp}$}
			\State{$\route^C_{bgp}(r, \lambda) = \gamma_{best}.nexthop$}
			\State{Redistribute $\gamma_{best}$ to OSPF domain}
			\Else \\
			\hspace*{0.7cm}\indent [Traffic for $\lambda$ will not exit domain through $r$]
			\State{$\route^C_{bgp}(r, \lambda) = \bot$}
			\EndIf
			\EndIf
			\EndProcedure
			%				\State{ . }
			%				\State{Prefer the path with the lowest \emph{multi-exit discriminator} (MED).}
			%				\State{Prefer eBGP over iBGP paths.}
			%				\State{Prefer the route that comes from the BGP router with the lowest \emph{router ID}.}
		\end{algorithmic}
	\end{footnotesize}
\end{algorithm}


\minisection{OSPF+BGP+Static Routes} We now describe how routing
happens across domains.  In domain $d$, let us consider a source
router $s$ (i.e., $\Theta(s) = d$) for sending traffic for destination
$\lambda$. Note that the traffic could originate from other domains;
then, $s$ indicates the first router in the domain.\loris{don't
  understand prev sentence} If the target router $t$ connected to the
destination belongs to domain $d$, then there exists a OSPF route for
$\lambda$ at $s$, and the path taken would be
$\route_{ospf}^C(s,t,\lambda)$.

Consider the case of destination $\lambda$ being connected 
to an external domain, thus, traffic for destination $\lambda$
will be sent to a BGP gateway router of domain $d$ which 
will forward it to its neighbouring domains till
it reaches the internal domain of $\lambda$. A BGP gateway
router is a router $g$ such that $\exists g' \in N(g). 
~\Theta(g') \not= \Theta(g)$. 

However, not all BGP routes for $\lambda$
are distributed 
into OSPF (to prevent explosion of forwarding tables). Instead,
BGP gateways in a domain exchange routes using iBGP to choose
the best gateway, which then redistributes the external
(eBGP route) into OSPF (\Cref{alg:bgppathrules}). If multiple
gateways advertise the destination $\lambda$ into the OSPF 
domain, then the closest gateway (in terms of OSPF distance)
is chosen. We define a gateway function $G^C$,
that given a domain number $n\in \nat$
%a local preference $LP$,
%a weight function $W$,
%route filters $RF$,
a router $r$ such that $\Theta(r)=n$,
and destination IP $\lambda$ outside of domain $n$, specifies the
gateway chosen for a destination based on both BGP and OSPF
configurations.\loris{how is prev func defined?} 
Finally, the routing function 
$\route^C$
%:\Theta \times LP \times W \times RF \times V \times V \times \Lambda \rightarrow L^* 
returns paths from source to destination in a inter-domain network. 
Given a source $s_1$, a destination $\lambda$ connected to target router $t$, 
\begin{multline}
	\route^C(s_1, t, \lambda) = 
	\route_{ospf}^C(s_1,g_1, \lambda) + 
	 (g_1, s_2 )+ \\
	~~~~~~~~~~~~~~~~~~~~~~~~~\route_{ospf}^C(s_2,g_2, \lambda) + (g_2, s_3) + \\
	\ldots  +\route_{ospf}^C(s_n,t,\lambda)
\end{multline}
where for each $i>1$, $g_i=G^C(\Theta(s_i),s_i,\lambda)$, 
$s_i=\route_{bgp}^C(g_{i-1}, \lambda)$,
and  $+$ is the concatenation operator for paths. 

\input{policy}

\minisection{Induced paths}
We assume a set of packet classes $PC : [0,C_{pc}]$ 
and map each path (specified by a reachability policy) \aditya{why
  just reachability?}   
to a unique integer in $PC$.
For a packet class $pc$, $src_{pc}$ denotes the source router,
$dst_{pc}$ denotes the destination router, and $\lambda_{pc}$
denotes the destination IP address. 


\begin{definition}[Induced Paths]
Given a configuration $C$ and a set of packet classes $PC$, the set of paths
$\paths^C(PC)$ induced by $C$ is defined as follows: 
$\forall pc \in PC.$ $\route^C(src_{pc}, dst_{pc}, \lambda_{pc})$ $\in \paths^C(PC)$.
\end{definition}

\subsection{Problem Definition}

\minisection{Policies}
\Cref{tab:policysupport} describes the path policies supported by \name.
Given  a set $\Psi$ of
path policies, we say that
a set of paths $\Pi$ is policy-compliant with respect to $\Psi$, $\paths^C(PC) \models \Psi$,
if the paths in $\Pi$ satisfy all the policies in $\Psi$ (see~\cite{genesis} for the formal definition).


\Cref{tab:configpolicysupport} describes all the configuration policies supported by \name.
For each configuration policy 
we define what it means for  a configuration $C=(T,\Theta,W,RF,LP,IBF,SR)$ to satisfy it.

The first type of policy restricts how many OSPF domains $N_D$ a
configuration might have, $c_1\leq N_D\leq c_2$, \loris{update table}
and it is satisfied by $C$ iff $c_1\leq |\{\Theta(r)\mid r\in V\}|\leq
c_2$.  This policy is useful for avoiding situation resulting in too
many domains in the hierarchical split which can be difficult to
administer.  The second type of policy allows the operator to restrict
the size $k$ of each OSPF domain, $l\leq k\leq u$, because OSPF does
not scale gracefully with network size.  This policy is satisfied if
for every domain $i$, $l\leq |\{r \mid \Theta(r)=i\}|\leq u$.


Certain 
	routers may not be suited to run BGP due to resource
	constraints. Thus, the operator can specify what set of 
	routers $B\subseteq V$ is BGP compatible.  
	This policy is satisfied if none of the routers $V\setminus B$
	is a gateway router.
	Formally, for every $r\in V\setminus B$,
	there doesn't exist a router $r'\in N(r)$ such that $\Theta(r) \not= \Theta(r_1)$

Finally, \name provides ways to specify upper bounds on the number of
1) route filters, which in general reduce the resiliency of the network---i.e., $rc=|\cup_{\lambda\in \Lambda} RF(\lambda)|\leq C_{rc}$,
2) static routes, which also affect resilience---i.e., $sc=|\{(v,\lambda)\mid \exists v'. SR(v,\lambda)=v'\}|\leq C_{sc}$, and
3) BGP configurations, which increase the complexity of the network~\cite{batfish, arc, era}---i.e., 
$bc=|\cup_{v,\lambda\in V\times\Lambda} IBF(v,\lambda)\cup \{(v,v',\lambda)\mid LP(v,v',\lambda)\neq \bot|\leq C_{bc}$.
\name also allows to minimize certain expression over the quantities $rc$, $sc$, and $bc$---e.g., $max(rc, sc+bc)$.

%different configuration metrics. For example,
%we allow route-filters in OSPF synthesis 
%(\secref{sec:ospfsynthesis}), which may yield undesirable
%endpoint resilience, thereby, synthesizing configurations
%which provide a specified metric of resilience or maximize
%the metric. Similarily, to enable path-based inter-domain routing, 
%\name needs	to set up static routes along the path, or configure BGP 
%variables like local preferences to ensure the configurations 
%induce the input paths.
%These increase the size of the configurations,
%thus increasing the complexity of verifying correctness either 
%manually or using verification tools~\cite{batfish, arc, era}. 
%Therefore,
%another objective \name considers is the configuration overhead
%to ensure path-compliance.

A configuration $C$ satisfies a set configuration policies $P$
if $C$ satisfies every constraint in $P$.

\minisection{Synthesis problems}
\noindent We can now define what it means for a configuration $C$ to be policy-compliant
and our synthesis problems.
\loris{quickly summarize what it means for paths to satisfy $\Psi$.}
\begin{definition}[Policy-Compliance]
	Given a set of path policies $\Psi$ and a set of configuration policies $P$,
	the configuration $C$ is policy-compliant with $(\Psi,P)$,
	$C \models (\Psi,P)$, if the set of
	induced paths $\paths^C(PC) \models \Psi$
	and $C$ satisfies the policies in $P$.
	The \emph{configuration synthesis problem} is to find, given $\Psi$ and $P$,
a configuration $C$ that is policy compliant with $(\Psi,P)$.
\end{definition}


\loris{remove $T$ everywhere from $C$, we will assume is fixed}

As anticipated in Section~\ref{sec:motivation}, our approach will proceed in two phases,
one of which solves the following sub-problem.  
\begin{definition}[Path-Compliance]
Given a set of configuration policies $P$,
and a set of paths $\Pi$ over packet classes $PC$,
	a configurations $C$ is path-compliant with 
	$(\Pi,P)$,
	if $\paths^C(PC)=\Pi$ and $C$ satisfies the policies in $P$.
	The \emph{path-compliance synthesis problem} is to find, given $P$ and $\Pi$,
a configuration $C$ that is path-compliant with $(\Pi,P)$.
\end{definition}




%We defined policy-compliance in terms of the 
%paths of the packet classes satisfying path-based 
%policies like isolation or traffic engineering. However,
%depending on the assignment of routers to different domains,
%the configurations generated may not be efficient
%in deployment. Therefore, we extend the notion of 
%compliance to policies on configurations 
%(\Cref{tab:configpolicysupport}).


