\section{Synthesising OSPF Configurations} \label{sec:synthesis}
In this section, we present an algorithm for 
solving the path-compliance problem for 
single-domain OSPF networks
---i.e., $|\{\Theta(n) \mid n\in V\}|=1$.

%\subsection{Complexity} \label{sec:rfcomplexity}

Before we present our technique and its intricacies,
we justify the complexity of our approach by showing that
the problem of synthesizing an OSPF configuration
that contains an optimal number of route-filters is NP-complete.

\begin{theorem}
Given a set of paths $\Pi$,
a topology $G=(V,E)$,
a domain-assignment function $\Theta$, such that $|\{\Theta(n) \mid n\in V\}|=1$,
a number $n\geq 0$,
the problem of finding 
an $LP$, $W$, and $RF$,  such that
\loris{PC shouldn't appear here, make consistent.}
$\paths(\Theta, LP, W, RF, PC) = \Pi$,
and 
$\sum_{\lambda\in\Lambda} |RF(\lambda)|=n$, is NP-complete.
\end{theorem}
\iffull
\input{route-filters-nphard}
\fi

%However, given a set of paths as input, there may
%not exist a solution to the edge weights. Consider the 
%input paths as shown in \Cref{fig:ospfexample}(b). 
%Both the red and blue paths are required 
%to be the unique shortest path between $s$ to $t$
%and, clearly, this is cannot be enforced for any 
%choice of the edge weights (as weights correspond 
%to all destinations). 
%One way to synthesize configurations in this scenario 
%is to ``disable'' the edge
%$(s, t)$ for destination $\lambda_1$.
%Using this technique, 
%there is only one possible path from $s$ to $t$
%for destination $\lambda_1$ ($s\rightarrow r_1 \rightarrow t$),
%therefore is chosen as the shortest path. For 
%destination $\lambda_2$, the $s\rightarrow t$ path
%has a smaller weight ($w=1$) than the
%$s\rightarrow r_1 \rightarrow t$ path ($w=1+2$), therefore,
%both traffic is forwarded through the input paths for
%both the destinations. 
%This blocking mechanism is called a route-filter, and
%we modify \name's OSPF synthesis algorithm to support
%route-filtering (\secref{sec:filtering}).
%

\begin{figure}
	\centering
	\subfloat[Edge Weights]{
		\raisebox{0.5cm}{\resizebox {0.5\columnwidth} {!} {
				\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
				square/.style={regular polygon,regular polygon sides=4}] 
				\node[state] at (0,0) (s)  {$s$}; 
				\node[state] at (1.8,1) (v1)  {$r_1$}; 
				\node[state] at (3.6, 0)(t) {$t$};
				\node[state, rectangle] at (5, 0) (d1) {$\lambda$};
				\path[->] 
				(s) edge node {1} (v1)
				edge  node {5} (t)
				edge [red, dashed, bend left=90] node {} (t)
				(v1) edge node {2} (t)
				(t) edge [red, dashed] node {} (d1);
				\end{tikzpicture}
			}}}
			\subfloat[Route-Filters]{
				\resizebox {0.5\columnwidth} {!} {
					\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
					square/.style={regular polygon,regular polygon sides=4}] 
					\node[state] at (0,0) (s)  {$s$}; 
					\node[state] at (2, 1) (v1)  {$r_1$}; 
					\node[state] at (4, 0)(t) {$t$};
					\node[state, rectangle] at (5.5, 0.75) (d1) {$\lambda_1$};
					\node[state, rectangle] at (5.5, -0.75) (d2) {$\lambda_2$};
					\path[->] 
					(s) edge node {1} (v1)
					edge  node [above] {1} node [below] {$rf((s,t),\lambda_1)$} (t)
					edge [red, dashed, bend left=90] node {} (t)
					edge [blue, dashed, bend right=45] node {} (t)
					(v1) edge node {2} (t)
					(t) edge [red, dashed] node {} (d1)
					(t) edge [blue, dashed] node {} (d2);
					\end{tikzpicture}
				}}
				\compactcaption{OSPF edge weights and filters such that the
					the routers forward traffic for destination along
					the input paths (dashed arcs).}
				\label{fig:ospfexample}
\end{figure}
			
\subsection{Simple OSPF Configurations} \label{sec:sarc}
 
For the OSPF protocol, configurations assign
 weights $W$ to links between routers (directed edges
 in the network topology);
 OSPF routers uses 
 Djikstra's algorithm to choose the
 shortest weighted path for a pair of endpoints. 
 Thus,
 given input paths, \name finds edge weights 
 (which are global for all paths) such that 
 the shortest path through the network
 for these endpoints exactly match the input paths. 
 For example in \Cref{fig:ospfexample}(a), if the input
 path is $s\rightarrow r_1 \rightarrow t$ for
 destination IP $\lambda$, \name assigns
 edge weights such that the input path has a strictly
 smaller weight ($W=1+2$) than the other path $s \rightarrow t$ 
 ($W=5$). Thus, the OSPF routers will forward traffic for
 $\lambda$ from $s$ to $t$ through $r_1$. We first
 consider the scenario of simple OSPF configurations (sOC)
 with no route-filters enabled.

The problem of synthesizing the
sOC that realizes an input set of paths reduces to a
variation of the so-called {\em inverse shortest path} 
problem~\cite{isp}. 
%Assume we are given the following inputs: (1) a directed graph $T = (S, L)$ (the network topology), 
%(2) a set of endpoints $\Gamma \subseteq S\times S$
%describing the sources and destinations of the input paths, and 
%(3) a function $P: \Gamma \rightarrow 2^{L^*}$
%that assigns to each pair of endpoints $(s,t) \in \Gamma$ 
%a set of \emph{acyclic} paths, such that for every path $l_0\cdots l_n\in P(s,t)$,
%$l_0=(s,s')$, for some $s'\in S$, and $l_n=(s'',t)$, for some $s''\in S$.\footnote{
%We use $L^*$ the denote the set of all finite sequences over $L$.}
%The 
%\emph{sARC synthesis}
%problem is to find rational weights for the edges in $L$ such that 
%for each pair of endpoints $(s,t) \in \Gamma$, 
%the paths in $P(s,t)$ are \emph{the} shortest paths from $s$ to $t$ 
%in the graph. Notice, that there can be multiple shortest
%paths of equal cost for multi-path support (e.g., for traffic engineering).
For a destination IP $\lambda$, we call $\xi_\lambda$ 
the directed tree of $T$ 
obtained by only keeping the nodes and edges 
that are traversed by paths in $\Pi$ for 
destination IP $\lambda$.
Since paths are acyclic, $\xi_d$ is a directed acyclic graph.
$\Delta=\{\xi_\lambda\mid \lambda \in \Lambda\}$ is   
the set of all destination trees. 

We use  $r_1\rightarrow r_2$ to denote $(r_1,r_2)\in L$ and
$r_1\rightarrow^* r_2$ (resp. $r_1\rightarrow^+ r_2$) to denote 
that $r_2$ is reachable from $r_1$ by crossing zero 
(resp. one) or more links in $T$.
Similarly, we use $\rightarrow_{\xi_\lambda}$ 
to denote the same relations in the destination trees.


\minisection{Distance equations}
To solve the sOC synthesis problem, 
we generate a set of linear equations
to find the edge weight $W(r_1, r_2)$ 
for all $(r_1, r_2) \in L$.
We use 
$D(r_1, r_2)$ to denote the 
shortest distance from $r_1$ to $r_2$.
We add the equation $D(s,s) = 0$ 
for every $s\in S$ to denote that the distance
from a node to itself is $0$.
The
following equation guarantees that $D(s,t)$ is not greater than 
the actual shortest distance from $s$ to $t$.
\begin{equation} \label{eq:dist}
\forall s, t. ~\forall r. ~r \in N(s).~
D(s, t) \leq W(s, r) + D(r, t)
\end{equation}

For each destination tree $\xi_d\in\Delta$, we add equations to ensure 
that the input paths with destination $d$ are indeed the shortest ones.
 If a path
is the shortest path between its endpoints, then every 
subpath of the path has to be the shortest between its endpoints
as well (otherwise the complete path would not be the shortest).

Consider a tree $\xi_d$ for destination $d$. We define two neighbour
functions: $N_T(s)$ denotes the set of neighbours of ritch $s$ 
in the input graph $T$, and $N_{\xi_d}(s)$ denote the set of
neighbours of ritch $s$ in the destination tree $\xi_d$. 
Given a destination $d\in \Omega$,
we use the following equations to ensure that, given two nodes $s$ and $t$ in
$\xi_d$, 
the set of paths from $s$ to $t$ in $\xi_d$ are
exactly
\emph{the} shortest paths from $s$ to $t$ in $T$.
Let $s$ and $t$ be two nodes in $\xi_d$ and let  $Paths_{\xi_d}(s,t)$ be the set of paths from $s$ to $t$ in $\xi_d$.
\begin{multline} \label{eq:uniq1}
		\forall l_0\cdots l_n\in Paths_{\xi_d}(s,t).
		\forall n' \in N(s) \setminus N_{\xi_d}(s). \\
		W(s, n') + D(n', t) > \sum_{\mathclap{\substack{l_i=(s_i,t_i)}}} 
		W(s_i, t_i) 
\end{multline}
\begin{multline} \label{eq:uniq2}
		\forall l_0\cdots l_n\in Paths_{\xi_d}(s,t).
		\forall n' \in N_{\xi_d}(s). n' \not\rightarrow^+_{\xi_d} t.  \\
		W(s, n') + D(n', t) > \sum_{\mathclap{\substack{l_i=(s_i,t_i)}}} 
		W(s_i, t_i) 
\end{multline}
\vspace{-2mm}
\begin{multline} \label{eq:uniq3}
		\forall l_0\cdots l_n, l_0'\cdots l_n'\in Paths_{\xi_d}(s,t).\\
		\sum_{\mathclap{\substack{l_i=(s_i,t_i)}}} 
		W(s_i, t_i)  =\sum_{\mathclap{\substack{l_i'=(s_i',t_i')}}} 
		W(s_i', t_i') 
\end{multline}
Equation~\ref{eq:uniq1} guarantees that 
the sum of the weights belonging to a path from $s$ to $t$ in $\xi_d$ is smaller than 
any path that goes to $t$ via a node $n'$ that is a neighbour of $s$ in $T$ but not in $\xi_d$.
Equation~\ref{eq:uniq2} guarantees that
the sum of the weights belonging to a path from $s$ to $t$ in $\xi_d$ is smaller than 
any path that goes to $t$ via a node $n'$ that is a neighbour of $s$ in $\xi_d$ but such that
$t$ is not reachable from $n'$ in $\xi_d$.
Finally, Equation~\ref{eq:uniq3} guarantees that all the paths from $s$ to $t$ in $\xi_d$ have the same weight.
