\section{Synthesising Routing Configurations}

In this section, we present algorithms for 
solving the path-compliance problem when the domain
assignment function $\Theta$ is given to us.
Before we present our techniques,
we justify the complexity of our approach by showing that
even the simplest variant of this problem is NP-complete.

\loris{why minimizing RF?}
\begin{theorem}[Hardness of synthesis]
\label{thm:ospfsynth}
Given a set of paths $\Pi$,
a topology $T=(V,L)$,
a domain-assignment function $\Theta$, 
the problem of finding 
a local preference  function $LP$, 
a weight function $W$, and 
and a route filter function $RF$,  such that
$C=(T,W,RF,LP,\Theta)$,
$\paths^C(PC) = \Pi$,
and 
$\sum_{\lambda\in\Lambda} |RF(\lambda)|$ is minimal is NP-complete.
\end{theorem}
\loris{adapt proof to simply say $n=1$}
\iffull
\input{route-filters-nphard}
\else
The reduction is from the vertex cover problem.
\fi
In the next two sections, we first show how to solve the intra-domain synthesis problem---i.e., when there
is only a single domain---and then how to solve the inter-domain synthesis problem---i.e., when
there are multiple domains.

\subsection{Synthesising Intradomain Configurations} \label{sec:synthesis}
In this section, we present an algorithm for 
solving the path-compliance problem for 
single-domain OSPF networks
---i.e., $|\{\Theta(r) \mid r\in V\}|=1$.
We first show how to solve the problem when
we are not allowed to use route filters
and then
extend our technique to handle route filters, when these are allowed.

\begin{figure}
	\centering
	\subfloat[Edge Weights]{
		\raisebox{0.5cm}{\resizebox {0.5\columnwidth} {!} {
				\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
				square/.style={regular polygon,regular polygon sides=4}] 
				\node[state] at (0,0) (s)  {$s$}; 
				\node[state] at (1.8,1) (v1)  {$r_1$}; 
				\node[state] at (3.6, 0)(t) {$t$};
				\node[state, rectangle] at (5, 0) (d1) {$\lambda$};
				\path[->] 
				(s) edge [red] node [black] {1} (v1)
				edge  node {5} (t)
				(v1) edge [red] node [black] {2} (t)
				(t) edge [red, dashed] node {} (d1);
				\end{tikzpicture}
			}}}
			\subfloat[Route-Filters]{
				\resizebox {0.5\columnwidth} {!} {
					\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
					square/.style={regular polygon,regular polygon sides=4}] 
					\node[state] at (0,0) (s)  {$s$}; 
					\node[state] at (2, 1) (v1)  {$r_1$}; 
					\node[state] at (4, 0)(t) {$t$};
					\node[state, rectangle] at (5.5, 0.75) (d1) {$\lambda_1$};
					\node[state, rectangle] at (5.5, -0.75) (d2) {$\lambda_2$};
					\path[->] 
					(s) edge [red] node [black] {1} (v1)
					edge [blue] node [above, black] {1} node [below, black] {$rf((s,t),\lambda_1)$} (t)
					(v1) edge [red] node [black] {2} (t)
					(t) edge [red, dashed] node {} (d1)
					(t) edge [blue, dashed] node {} (d2);
					\end{tikzpicture}
				}}
				\compactcaption{OSPF edge weights and filters such that the
					the routers forward traffic for destination along
					the colored paths.}
				\label{fig:ospfexample}
\end{figure}
			
			
			\loris{route-filters vs route filters}
\subsubsection{Intra-domain Synthesis Without Route-filters} \label{sec:sarc}
 
When no route-filters are allowed,
 OSPF routers use the edge weights $W$
 to choose the
 shortest weighted path for each pair of endpoints. 
Our goal is to synthesize a $W$.
 For example in \Cref{fig:ospfexample}(a), if $\Pi$ 
 contains the 
 path $\pi=s\rightarrow r_1 \rightarrow t$ for
 destination IP $\lambda$, \name will assign
 edge weights so that $\pi$ has
 smaller weight ($W(\pi)=1+2$) than the path $\pi'=s \rightarrow t$ 
 ($W(\pi')=5$). 
 
The problem of synthesizing the weight function $W$ that
realizes an input set of paths $\Pi$ is
a
variation of the so-called {\em inverse shortest path} 
problem~\cite{isp}. 
For a destination IP $\lambda$, we call $\xi_\lambda$ 
the directed tree of $T$ 
obtained by only keeping the nodes and edges 
that are traversed by paths in $\Pi$ for 
destination IP $\lambda$, the root of the tree
is the destination router connected to $\lambda$. 
 This destination tree
 property is due to the modifications in \genesis
 to support OSPF's destination-based forwarding. We
 define $\Delta=\{\xi_\lambda\mid \lambda \in \Lambda\}$,   
the set of all destination trees. 

Given a set of input paths $\Pi$, \name 
generates a set of linear constraints to 
find proper weights $W(r_1,r_2)$ 
for all $(r_1, r_2) \in L$.
The constraints use the variable $W_{r_1}^{r_2}$
to denote the weight of the edge $(r_1, r_2)$, and the variable
$D_{r_1}^{r_2}$ to denote the 
shortest distance from $r_1$ to $r_2$.
We add the equation $D_{s}^{s} = 0$ 
for every $s\in S$ to denote that the distance
from a node to itself is $0$.
Equation~\eqref{eq:dist} guarantees that $D_{s}^{t}$ is smaller or equal to
the shortest distance from $s$ to $t$.
\begin{equation} \label{eq:dist}
\forall s, t. ~\forall r \in N(s).~
D_s^t \leq W_s^r + D_r^t
\end{equation}

For each destination tree $\xi_\lambda\in\Delta$, we add equations to ensure 
that the input paths with destination $d$ are the shortest ones.
Notice that, if a path $\pi$
is the shortest path between its endpoints, every 
subpath of $\pi$ also has to be the shortest path between its endpoints.
For each tree $\xi_\lambda$, we define the neighbour
 $N_{\xi_\lambda}(s)$ to denote the 
next-hop neighbour of router $s$ in the destination tree $\xi_\lambda$---i.e., the parent
of $s$ in the tree or no node if $s$ is the root of the tree.
%Since $\xi_\lambda$ is a directed tree, every router $r \in \xi_\lambda$
%has one next-hop router, therefore $N_{\xi_\lambda}(s)$ is a singleton
%set (the root of the tree (router connected to $\lambda$) has no next-hop
%routers).

The following equations ensures that, for any 
 two nodes $s$ and $t$ in
$\xi_\lambda$, if $t$ is reachable from $s$, 
the path $l_0\cdots l_k$ from $s$ to $t$ in $\xi_\lambda$ is the 
\emph{unique shortest path} from $s$ to $t$ in $T$.
\begin{multline} \label{eq:uniq1}
\forall r \in N(s) \setminus N_{\xi_\lambda}(s).~~
W_{s}^{r}+ D_{r}^{t} > \sum_{\mathclap{\substack{l_i=(r_1,r_2)}}} 
W_{r_1}^{r_2}
\end{multline}
Equation~\ref{eq:uniq1} guarantees that 
the sum of the weights belonging to a path from $s$ to $t$ in $\xi_\lambda$ 
is strictly smaller than 
any path that goes to $t$ via 
a node $n'$ that is a neighbour of $s$ in $T$ but not 
the next-hop in $\xi_\lambda$.

\subsubsection{Intra-domain Synthesis with Route-filters} \label{sec:routefilter}

If the system of equations presented Section~\ref{sec:sarc} admits a solution, 
the values of the $W$ variables are the weights we are trying to synthesize,
otherwise the intra-domain synthesis problem cannot be solved without using route-filters.
In this section, we showed how the proposed technique can be modified
to support route-filters---i.e., when $n>0$.

A route-filter  can selectively disable an
edge for a given destination by  blocking advertisements to a
particular destination along a link.
We start by observing that the intra-domain synthesis problem with route-filters
admits a trivial solution in which 
route-filters are used to enforce the exact set of input paths by blocking all other possible paths.
\loris{double-check this notation}
This can be done by creating a 
route-filter $(l,d)$ for every link $l$ not in $\xi_d$. 
However, this solution will place many more filters than necessary.
Since the problem of optimally placing route-filters is NP-complete, 
we propose a greedy strategy that does not guarantee a minimal number of filters, but works well in practice.


Our algorithm starts by trying to synthesize a solution
that does not use route-filters using the equations proposed in \secref{sec:sarc}. 
In the case of a failure, the algorithm uses the ``proof of unsatisfiability''---i.e., the unsatisfiable core---generated by 
the constraint solver 
to greedily add a small set of route-filters. 
New modified equations are then generated to model the added route-filters and the approach is repeated until a solution is found.
We first describe the 
modified linear equations generated when a set of
route-filters are enabled, and then describe two
techniques used to choose route-filters. 

\minisection{Equations with route-filters}
\loris{why do we need to modify \eqref{eq:dist}? Can't we just add $D_s^t(d)\geq D_s^t$ for
all $d$}
We assume we are given a set of route-filters $RF$ and 
use $s\rightarrow_d^* t$ to denote that $s$ can reach $t$
\loris{again double check notation}
in $T$ without using any edge $l$, such that $(l,d)\in RF$.
We use the variable $D_{r_1}^{r_2}(d)$ to denote the shortest distance from $r_1$ to $r_2$
using only edges that are not filtered for destination $d$.
We can revise equation \eqref{eq:dist} and   to correctly restrict the values of 
each variable $D_{s}^{t}(d)$
by simply ignoring all the filtered edges. 
We will add one modified version of equation \eqref{eq:dist} for each destination $d$.
Similarly, we add modified versions of equation  \eqref{eq:uniq1}.

While the encoding without route-filters produces $n$ equations, this
encoding produces $|\Omega|n$ equations due to the multiple different distances
$D_s^t(d)$.  Notice that, the shortest distance $D_s^t(d)$ between two
nodes $s$ and $t$ without using edges filtered for $d$ cannot be
smaller than the shortest distance $D_s^t$ obtained without
considering route-filters.  
We use this property to simplify the
encoding by only computing $D_s^t$ and by replacing each instance of
$D_s^t(d)$ with $D_s^t$ in equations \eqref{eq:uniq1}.  It is easy to see that 
if the set of constraints with variables $D_s^t(d)$ admits a solution,
the corresponding set of constraints with variables $D_s^t$ 
also admits a solution (because $D_s^t\leq
D_s^t(d)$).  However, the reverse is not true and the set of
simplified equations can be unsatisfiable in cases in which the
original set is satisfiable, causing addition of unnecessary filters.
Our implementation uses this simplified set of equations, but we will
show that this does not effect our ability to find good solutions in
Section~\ref{sec:evaluation}.


%% We discuss two schemes  to add route-filters:
%% the first scheme 
\minisection{Adding filters using unsatisfiable cores}
When the set of linear equations does not admit a solution, we 
add router-filters until, eventually, a solution is found.
Our scheme for adding route filters
uses unsatisfiable cores generated
by the solver.
%% and the second scheme 
%% finds topological structures called diamonds that 
%% can never be handled without route-filters.\loris{do we leave this?}

LP-solvers have efficient procedures to return an
unsatisfiable core, also called IIS (Irreducible Inconsistent Subsystem)~\cite{chinneck2007feasibility}. 
Formally, an IIS is a subset of constraints such that,
if all constraints except those in the IIS are removed, the resulting set of
linear equations is still inconsistent (unsatisfiable). Moreover, the set is irreducible---i.e., removing 
any one constraint of the IIS produces a consistent set of constraints. 
When the solver returns unsatisfiable and produces
an unsatisfiable core,
some of the linear inequalities from 
Equations \eqref{eq:uniq1} and  \eqref{eq:uniq2}
will appear in the unsat-core 
(an unsat-core cannot consist of only 
constraints from \Cref{eq:dist} and \eqref{eq:uniq3}, as all distances and edges set to zero
would trivially be consistent with these constraints). 
In particular, the unsat-core contains some constraint
\begin{eqnarray}
W_s^r + D_r^t  > \sum_{\mathclap{\substack{l_i=(r_1,r_2)}}} 
		W_{r_1}^{r_2}
\end{eqnarray}
that was added to reason about some DAG\loris{DAG or tree. bit confused.} $\xi_d$.

By adding the route-filter $((s,n'),d)$ to $F$, this inequality is removed from the set of constraints
and the combination of the other constraints appearing in the other unsat-core is now satisfiable.
The new set of equations may still be unsatisfiable and other unsat-cores might exist. 
The procedure is repeated until the resulting set of constraints becomes satisfiable
and we have reached a solution to the intra-domain synthesis problem.




