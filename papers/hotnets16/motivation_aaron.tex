\section{Vision and Challenges} \label{sec:vision}
% Programming a legacy network control plane to satisfy a variety of
% connectivity, security, and performance policies is a complex and error-prone
% task. We have shown that program synthesis is a promising approach to automate
% this process and produce a control plane that is ``correct-by-construction.''
% In particular, we presented an architecture where a network operator provides
% a policy-compliant data plane and a set of hard and soft policies as input,
% and the system automatically provides a set of device configurations that
% leverage the control plane features available on each device to compute
% policy-compliant paths, even in the presence of failures.  Formulating a
% tractable synthesis problem and maximizing the number of satisfied soft
% policies are the key challenges in realizing this vision. We show these
% challenges can be overcome by modeling the control plane using a graph-based 
% abstract representation tied to a traditional shortest path algorithm and
% iteratively transforming the abstract representation based on feedback from
% the satisfiability (SAT) solver and characteristics of the graph. However, we
% have only explored how to address a subset of important policies and leverage a
% few available control plane features on traditional networking hardware. Our
% future work will focus on satisfying a wider range of policies using more
% features, and we will study how to best translate our abstract representation
% into actual device configurations to make our system practical for use with
% real networks.

One of the foremost tasks in network management is programming the network to
forward traffic in a manner consistent with user- and application-induced
policies. Common types of policies include: reachability (i.e., which
end-hosts can communicate), isolation (i.e., which flows cannot share links),
service chaining (i.e., which middleboxes must be traversed), resilience
(e.g., how many backup paths are available), and traffic engineering. Every
set of forwarding paths (i.e., data plane) installed in the network---either
manually or by a control plane---should conform to these operator-provided
policies, otherwise performance, security, or availability problems may arise.

A variety of techniques can be used to determine the appropriate forwarding
paths. One option is to compute a data plane offline, and install the data
plane using an API that allows direct control of switches' forwarding tables
(e.g., OpenFlow). Several recent works~\cite{merlin, simple} have adopted this
approach, using solvers to automatically compute a data
plane that conforms to a set of policies. \aaron{need to say what is wrong
 with this approach} A second option is to dynamically compute forwarding
paths at a logically centralized controller---i.e., use a software-defined
networking (SDN) control plane. However, this requires developing algorithms
that take the set of policies and the current state of the network (e.g.,
which links have failed) as input and output paths that conform to a
multiplicity of policies.  Most existing SDN control applications only compute
paths based on one or a few types of policies: e.g., service
chaining~\cite{simple, flowtags}, traffic engineering~\cite{swan, b4}, or
resilience~\cite{plinko}. Furthermore, the controller may become bottlenecked
or fail (even if it is distributed), leading to (a partial) network failure.

A third option, which continues to be the most widely adopted, is to
dynamically compute forwarding paths using distributed routing protocols
running on ``legacy'' network switches---i.e., use a ``traditional'' network
control plane. This avoids the scalability, failure tolerance, and \aaron{what
else?} challenges of the other two approaches. However, programming (i.e.,
configuring) a traditional control plane to compute policy-compliant paths
remains challenging for several reasons: (1) the path-computation algorithms
are pre-defined---e.g., OSPF uses Dijkstra's shortest path---and their
behavior can only be influenced through a limited set of parameters---e.g.,
link weights; (2) there is often no direct mapping between policies---e.g.,
isolation---and configuration options---e.g., link weights and route filters;
and (3) a single set of parameters must result in policy-compliant paths under
all possible network states---e.g., all combinations of link failures.
\aaron{Anything else?}

These issues motivate us to design a system that automatically synthesizes
(configurations for) a control plane that computes policy-compliant paths
under all possible network states.
Unfortunately, this task is inherently challenging as it requires solving in one shot multiple
computationally hard problems.
For example, even when considering static routing and no failures, synthesizing a control plane that satisfies  policies such as isolation and waypoints
is an NP-hard problem.
Although the progress in SMT solving has made many NP-hard problems more practical, 
 attempts of incorporating concepts such as shortest path algorithms 
into these solvers have resulted into huge performance losses~\cite{monosat}. 
Finally, adding failure-handling to the problem results in yet another layer of combinatorial explosion.

Our proposed approach is to tackle these three problems in separate phases.
By choosing a data plane as input to the second phase, we 
express the problem of finding a control plane using only the 
theory of linear rational arithmetic (LRA), for which we can use
efficient off-the-shelf LP-solvers. 
This approach causes information to be lost between the different phases;
the data plane generated by the first phase may not be suitable to 
synthesize a control plane conforming to all policies required, and 
the synthesis could fail in the second or third phase. 
However, our architecture can overcome this shortcoming 
by performing
multiple iterations of the first phase to produce different 
candidate data planes for the second and third phases.
Our preliminary results for the three-phase
approach show encouraging performance, and we 
postulate the implementation of 
efficient procedures to enumerate different data 
planes satisfying the input policies for a 
producer-consumer model to make the synthesis of 
control planes from policies tractable.  

The solution space of output network configurations to 
enforce a set of policies
is large; configurations can use different 
network protocols (e.g., only BGP, only OSPF or a hybrid) and
mechanisms (e.g., route filters, access control lists
or protocol-specific variables). The large solution space
of configurations complicates the synthesis of
network configurations from
input policies, 
or ties the synthesis to a particular type of configuration. 
Instead, we borrow a page from programming languages
research and
synthesize an Abstract Representation for Control planes (ARC)~\cite{arc} 
from the data plane; the ARC can then be translated to actual device configurations.
The ARC uses the notion that most routing protocols in use 
today employ a cost-based path selection algorithm; thus a weighted
graph can be used to abstractly represent the control plane such that 
the path between two points taken in the network would be 
the lowest weight path in the graph. 
The ARC effectively decouples the policy component with the 
actual network infrastructure. 

While we use an abstract representation of the control
plane (ARC) to simplify the synthesis, operators need control 
planes conforming to certain requirements of the 
underlying network infrastructure. For example, a 
network may comprise of switches which do not have custom
features like ACLs or route-filters, thus the ARC must take 
into consideration these requirements. Without losing 
generality, we translate these 
requirements as types of ARCs with different properties,
and still use a protocol-independent representation
to represent the control plane. 

In this paper, we show the preliminary treatment 
of the second and third phase of the our three-phased
approach, i.e synthesizing a control plane from a set 
of input paths and transforming the control plane to 
satisfy policies under failure scenarios. The first 
phase has seen promising work in recent times~\cite{merlin,
simple}, these systems generate data planes to enforce 
different kinds of policies, and 
we can be retrofit these systems to generate different 
data planes to integrate in our three-phase approach.

% thus, the networking infrastructure could be
% transitioned to different protocols without affecting the policy 
% control of the architecture. From the ARC, we can construct different
% drivers for translation to actual device configurations; these drivers
% can leverage inferences from healthy network practices in 
% real-life networks~\cite{mpa-imc15} to produce ideal network configurations.


%\aaron{Old text below}
%
%To tackle synthesis 
%of distributed control planes, 
%we use as input the network data plane 
%(set of forwarding paths) \aaron{Where does this data plane come from and
%    why is it reasonable to assume an operator can provide one?} which 
%enforces the operator-specified policies to
%synthesize an abstract representation of the control plane
%called ARC. \aaron{Our approach (ARC) should not come up until later in the
%    motivation, if at all.}
%The advantage of using network data planes as 
%input is the ease of developing
%different network management applications 
%enforcing proactive policies\footnote{
%Traditional control planes cannot support reactive policies, however
%middleboxes can overcome this limitation.} 
%as if operating over a software-defined
%network, agnostic of the actual network protocols used in the network.
%\aaron{I don't understand the preceding sentence. I'm still not clear why you
%take a single data plane as input and not multiple data planes or just the
%policies. I realize it is hard to synthesize from the latter, but can you be
%more precise why it is hard?}
%Many existing network management systems like Merlin~\cite{merlin} 
%and SIMPLE~\cite{simple}\footnote{
%Traditional control planes cannot support 
%paths with loops for service chaining.} developed for SDNs 
%could be seamlessly integrated to the architecture with minimal changes.
%\aaron{Do we need the preceding sentence?}
%Thus, using the data plane as input, we synthesize a control plane
%such that the paths decided by the control plane are the same 
%as the data plane input, and these paths satisfy the operator 
%policies.
%
%However, the control plane does not guarantee policy compliance 
%when failures occur. For
%example, if a link along the shortest path 
%%(\aaron{refer to some example figure}) 
%fails, \aaron{Need to mention earlier that we assume shortest-path-based route
%computations, ala OSPF} the next shortest path will become the new path to reach the
%destination. The control plane automatically computes the new shortest path
%(assuming one exists), thus preserving connectivity. 
%However, the new path may
%not conform to the same policies as the path in the 
%original failure-free data
%plane from which the control plane was synthesized: 
%e.g., the new path may no longer
%traverse a waypoint or have the same bandwidth capacity. Thus,
%synthesis must take into account policy-compliance under failures.
%
%Policy-compliance under failures is difficult to achieve due 
%to the large number of failure scenarios to consider and can 
%be impossible to synthesize a control plane which is 
%policy-compliant under all failures. Operators require 
%varying degrees of policy-compliance under failures for 
%which we propose two classes of policies: {\em hard} and
%{\em soft} policies. Operators can specify 
%hard policies pertaining
%to security are of the utmost importance, 
%because they protect the network and
%its services from attacks and unauthorized accesses. Some 
%examples of hard policies are as follows: 
%a particular flow must always traverse through a waypoint 
%under any failure scenario, or a certain pair of hosts must 
%never be able to communicate (always blocked). 
%Soft policies can be considered as objectives which improve 
%the control plane, but are not strict requirements, typically
%pertaining to performance. The consequences of violating
%soft policies are less severe. Operators can provide 
%backup paths for flows (generated such that they 
%satisfy the data plane policies) as soft policies, 
%and the synthesis of the control plane 
%tries to satisfy as many soft policies as 
%possible. 
%
%\aaron{Discussion of the available control plane constructs should come up
%    earlier.}
%While we use an abstract representation of the control
%plane (ARC) to simplify the synthesis, operators need control 
%planes conforming to certain requirements of the 
%underlying network infrastructure. For example, a 
%network may comprise of switches which do not have custom
%features like ACLs or route-filters, thus the ARC must take 
%into consideration these requirements. Without losing 
%generality, we translate these 
%requirements as policies determining the properties of the
%ARC, and thus, still use a protocol-independent representation
%to represent the control plane. 
%
%Our architecture envisions network operator providing
%a policy-compliant data plane and a set of hard and soft policies
%pertaining to policy-compliance under failure and network 
%infrastructure requirements as input to synthesize resilient 
%control planes. Towards this vision, we present  
%approaches to synthesize different types of the ARC and the 
%challenges involved in making synthesis efficient and
%extending these approaches to support a wider range of 
%policies and functionalities. 
