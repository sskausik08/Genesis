\section{Synthesising Domain Assignments}
\label{sec:synth-dom-ass}
Many networks today have well-defined routing hierarchies to realize a variety of administrative  policies or division of responsibilities. For example, a campus network may be hierarchically divided into multiple routing domains (e.g., OSPF Areas) corresponding to different departments. Often, these hierarchies are realized through careful planning, and require detailed configurations, e.g., to determine which routers to include in a particular OSPF routing domains, how many such domains to create, how big to make each domain etc. Unfortunately, this makes the hierarchical division painstaking and error-prone, but also the careful planning means that changes to the hierarchies, e.g., to accommodate more hosts or new policies, are difficult to implement.

In such settings, Zeppelin can help by automating domain creation/restructuring. It can automatically find good routing domain hierarchies with increased resilience/decreased complexity and policy compliance. We envision that operators will synthesize “one-shot” domain assignments for their changing input policies at coarse-grained timescales (days/weeks) when there are significant changes to their networks or policies; operators need not resynthesize these assignments for every low-level policy change.


In this section, we present an algorithm for 
solving the path-compliance synthesis problem when a domain assignment is not given to us (Definition~\ref{def:pathcompliance}).
The algorithm searches the space of possible domain assignment $\Theta$ to find
one that meets all configuration policies and has good quantitative properties---e.g., minimizes
the number of static routes. 
%Formally, we are given 
%a topology $T=(V,L)$, a set of paths $\Pi$ and
%configuration policies $P$, 
%we want to find functions
%$W,RF,LP,IF,SR$ and $\Theta$ such that
%$C=(\Theta,W,$ $RF,LP$,$IF,SR)$,
%$C$
%We call this problem the \emph{domain assignment problem}.
%
We first show that when the domain assignment is not given,
even the simplest variant of the path-compliance assignment problem
is computationally hard.
\begin{theorem}
If $P$ disallows the use of static routes ($sc \leq 0$)
the path-compliance synthesis problem is NP-complete.
\end{theorem}
\iffull
\input{dom-ass-nphard}
\fi

Given the complexity of this problem, we opt for a greedy
stochastic search.
\name searches the space of assignments using Markov
Chain Monte Carlo (MCMC) sampling methods, specifically the Metropolis-Hasting
algorithm, a common technique used in several optimization 
problems~\cite{stoke}. 
We first present the general structure of our search 
algorithm and 
then describe how the quantities 
in Table~\ref{tab:configpolicysupport} can be computed
or estimated to drive the search.



\subsection{Searching Assignments with MCMC}
MCMC sampling is a technique for 
drawing elements from a
probability density function in direct proportion to its value.
In our setting, MCMC searches the space of domain assignments and,
if we assign higher probabilities to domain assignments with lower cost, MCMC will explore
good configurations more \emph{often} than bad ones.
For MCMC to work we need to provide a transition function that lets us move from one domain assignment
to another with a certain probability and a cost function that assigns costs (and therefore probabilities) to
domain assignments. 

In our setting, each domain assignment $\Theta$
has an associated cost $c(\Theta, e)$
where
$e=expr(rc, sc, bc)$
is the expression we are trying to minimize---e.g., if we are trying to minimize the number of static routes $e=sc$.
We will discuss how our cost function is implemented in the Section~\ref{sec:cost-fun}.
%Given the cost function $c(.)$ and probability density 
%function $p(.)$, 
%the Metropolis acceptance probability~\cite{metropolis}
%for a transition from $\Theta \rightarrow \Theta'$ is as follows:
%\begin{multline}
%Pr(\Theta \rightarrow \Theta') = min(1, \frac{p(\Theta')}{p(\Theta)}) \\
%= min(1, exp(-\beta.(C(\Theta') - C(\Theta)))
%\end{multline}
%where $\beta$ is a positive constant. With the Metropolis
%algorithm, we can perform MCMC without calculating the actual
%probability density function $p(.)$, the arbitary cost function $c(.)$
%will suffice.

The search starts by setting the current domain assignment 
to some random domain $\Theta_0$.
The following process then repeats.
Given the current domain
assignment $\Theta$, 
compute a new domain assignment $\Theta'$ by randomly
moving a gateway 
router $r$ from one domain to another---i.e., $\Theta(r){\neq}\Theta'(r)$ and
for every $r'{\neq} r$, $\Theta(r'){=}\Theta'(r')$.
If $c(\Theta',e)\leq c(\Theta,e)$, then $\Theta'$ becomes the current domain assignment.
If $c(\Theta',e)>c(\Theta,e)$, then $\Theta'$ becomes the current domain assignment
with probability $Pr(\Theta \rightarrow \Theta')= exp(-\beta\times(c(\Theta',e) - c(\Theta,e))$ (where $\beta$ is a positive constant) 
while 
 $\Theta$ continues being the current domain assignment with probability $1-Pr(\Theta \rightarrow \Theta')$.
\iffull
The procedure is illustrated in \Cref{alg:mcmc}.
\fi

The algorithm always accepts a new proposal $\Theta'$
that has cost lower than $\Theta$. If $\Theta'$ has a 
higher cost than $\Theta$, the proposal is
accepted with probability inversely proportional to
how far the costs of $\Theta$ and $\Theta'$ are. This ensures that 
the algorithm does not get stuck at local minima, but 
explores proposals with small cost differences with 
higher probability.

\iffull
\begin{algorithm}[t]
	\floatname{algorithm}{Algorithm}
	\caption{Markov Chain Monte Carlo search for  finding a
	domain assignment that minimizes the expression $e$}
	\label{dcsyn}
	\begin{algorithmic}[1] \label{alg:mcmc}
		\Procedure{MCMCSearch}{$e$}
		\State{$\Theta \leftarrow$ random domain assignment}
%		\State{$\overline{cc} = 0$ \hspace{2cm} [Worst Conf. overhead]}
%		\State{$\overline{rc} = 0$ \hspace{2cm} [Worst route filter est.]}
		\While{max iterations OR timeout}
		\State{$\gamma$ = \Call{Cost}{$\Theta, e$}}
		\State{$\Theta'$ = \Call{RandomChange}{$\Theta$}}
		\State{$\gamma'$ = \Call{Cost}{$\Theta, e$}}
%		\State{$Pr(\Theta \rightarrow \Theta')$ = 
%			min$(1, exp(-\beta.(\gamma' - \gamma))$}
		\State{Set $\Theta$ = $\Theta'$ with 
			probability $Pr(\Theta \rightarrow \Theta')$}
		\EndWhile
		\EndProcedure
		
%		\Procedure{Cost}{$\Theta$} 
%		\State{$cc \leftarrow$ Configuration overhead (Static routes + \newline \hspace*{1.5cm} 
%			BGP local preference entries + iBGP filters)}
%		\If{$cc > \overline{cc}$} 
%		\State{$\overline{cc} = cc$}
%		\EndIf
%		\State{$rc \leftarrow$ Number of diamonds with  \newline 
%			\hspace*{1.3cm}  endpoints in same domain }
%		\If{$rc > \overline{rc}$} 
%		\State{$\overline{rc} = rc$}
%		\EndIf
%		\State{$\gamma$ = max($cc/\overline{cc},
%			\alpha.rc/\overline{rc}$)  \newline
%			\hspace*{3.5cm} + 0.1*min($cc/\overline{cc},
%			\alpha.rc/\overline{rc}$)}
%		\State{\Return $\gamma$}
%		\EndProcedure
%		
%		\Procedure{RandomChange}{$\Theta$}
%		\While{True}
%		\State{$r \leftarrow$ pick random boundary router}
%		\State{$\theta \leftarrow$ pick random neighbouring domain of $r$}
%		\If{$|\Theta(r)| - 1 \geq l_\Theta \wedge |\theta| + 1 \leq u_\Theta$}
%		\State{$\Theta' \leftarrow \Theta[r \rightarrow \theta]$} \hfill [$r$'s domain changed to $\theta$]
%		\If{domains are continous}
%		\State{\Return $\Theta'$}
%		\EndIf
%		\EndIf
%		\EndWhile
%		\EndProcedure
	\end{algorithmic}
\end{algorithm}
\fi

\subsection{The Cost of a Domain Assignment}
\label{sec:cost-fun}
In the previous section, we presented the general structure of our search algorithm,
but we did not specify how the cost function $c(\Theta,e)$
is computed. 
%By looking at our policy language in Table~\ref{tab:configpolicysupport},
%we see that the expression $e$ may contain
%the number of route filters $rc$,
%the number of static routes $sc$,
%and the number of BGP configuration entries $bc$.
Computing the cost $c(\Theta,e)$ amounts to substituting in $e=expr(rc, sc, bc)$
the values of $rc$,
$sc$, and $bc$ for the configuration $\Theta$.
The techniques presented in Section~\ref{sec:inter-synthesis} provide a way to 
synthesize BGP configurations and static routes for a given domain assignment
and can be used to 
efficiently compute the quantities $sc$ and $bc$.
However, we showed that, given a domain assignment, computing the  minimal required number of route filters $rc$
is a challenging problem (Theorem~\ref{thm:ospfsynth}).
Since we want MCMC to explore as many assignments as possible,
we present a heuristic technique for estimating the number of route filters required by a domain assignment. 

We say that two paths $\pi=(r_1,r_2)\cdots (r_{n-1},r_n), \pi'=(r_1',r_2')\cdots (r_{n-1}',r_n')$ with destinations $\lambda$ and $\lambda'$
form an $(r_i, r_j, \lambda, \lambda')$\emph{-diamond} if and only if
there exists $i,i',j$, and $j'$ such that $i<j-1$, $i'<j'-1$, and
\begin{multline}
r_i{=}r_{i'}' \wedge  r_j{=}r_{j'}' \wedge  \forall i{<}k{<}j.~\forall i'{<}k'{<}j'.~r_{k}{\neq} r_{k'}'  
\end{multline}
Intuitively, a diamond is the smallest structure formed by two
paths intersecting at $r_i$ and $r_j$ with edge-disjoint paths in 
between these routers. 

If the paths $\pi$ and $\pi'$ completely lie in the same domain,
the presence of a diamond 
implies that OSPF needs to compute two different shortest paths between $r_i$ and $r_j$, 
which means that
at least one route filter is required.
On the other hand, if $r_i$ and $r_j$ lie in
different domains, no route filters are required to resolve this diamond. 
%\loris{not sure if following sentence needed}
%In the limiting
%case where each router is a separate domain of size 1,
%no route filters are required, and the entire 
%network can be configured using BGP. 




Before  starting the MCMC search, \name precomputes
the set of all diamonds induced by the paths $\Pi$. 
For each
domain assignment $\Theta$,
\name estimates the number of required 
route filters $rc$ by counting for 
how many $(r_i, r_j, \lambda, \lambda')$-diamonds
$\Theta(r_i) = \Theta(r_j)$. 
Notice that two different diamonds that share an edge could be resolved
by placing a single filter on the shared edge, whereas our estimated route filter cost 
would be 2. 
%\loris{I think this is true, but not sure if necessary.
%Intuitively, our algorithm is similar to the greedy algorithm for solving vertex cover~\cite{}, and 
%using a similar argument,
%we can show that our estimate produces at most twice as many route filters as the ones 
%needed to eliminate all diamonds.}

While diamonds in the same domain definitely require route filters, there might be
sets of paths that do not contain diamonds but that still require route filters
and are not
taken into account in our estimate. 
However, our diamond-based estimate
can be computed efficiently and 
our experiments  show that reductions 
in cost lead to decreased number of filters
and increased endpoint resilience (\Cref{sec:mcmceval}).

%\minisection{Cost of Configuration Overhead} 
%Given a domain assignment $\Theta$, the exact number of static routes,
%BGP local preferences, and iBGP filters can be computed 
%efficiently  using the techniques from \Cref{sec:synth-multi}).
%We can use the sum of these three quantities to quantify the
%configuration cost $cc$.\loris{is the content of the footnote consistent with our policy lang}\footnote{
%	Operators can specify relative weights of each overhead, for e.g.--an
%	operator may want to reduce only static routes.}.

%\minisection{Overall Cost Function} 
%\loris{rewrite this after policy language already takes this into account. 
%The it will be all about estimating the quantities in the objective and the aggregation will be for free.
%This para will go.}
%Finally, we need to combine the
%route filter cost ($rc$) and configuration cost ($cc$) 
%based on the preference specified by the operator. 
%Interestingly, these two quantities are inversely related. 
%If the whole network is a single OSPF domain, $rc$ is maximum, while
%$cc$ is 0. Similarly, if all routers are in different domains
%$cc$ is maximum while $rc$ is 0. 
%If the operator requires to
% jointly minimize both these quantities, we
%will use a combined cost of the form $\rho=max(RC, \alpha*CC)$ where $\alpha$ is a tunable parameter
%that can assign weight to the two quantities. Here,
%$RC$ and $CC$ are normalized versions of the costs
%obtained by dividing $rc$ and $cc$  by the worst costs seen during the MCMC search.
%Therefore, initially $\rho=1$ and later on $\rho$ is the improvement of the current configuration over
%the worst in terms of either configuration overhead or route filter cost.
%\loris{I think the above trick breaks MCMC by making you stuck in local optima.
%What happens if we remove it? Also unnecessary detail.}