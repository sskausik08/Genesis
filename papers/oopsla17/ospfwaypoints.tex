\section{Waypoint-Compliance Synthesis}
When a tenant specifies a waypoint policy, for e.g., traffic from
subnet A to subnet B must traverse through a firewall, they are not
concerned with the exact path through the network except that the 
path goes through any of the firewall instances, which are replicated 
for resiliency and load-balancing purposes. Thus, we can define 
logical waypoints and map each logical waypoint to a set of physical
locations, and \name must ensure the path traverses through the logical waypoint.

\subsection{Problem Statement}
Instead of enforcing the
exact \genesis path, we incorporate waypoint-compliance in the 
intra-domain configuration synthesis. However, this can only 
support a subset of waypoint policies and more complicated policies
can be enforced using the \genesis paths. 
Formally, we can synthesize intra-domain configurations
for an unordered waypoint policy with packet class $pc$ of the form: 
\texttt{$\lambda$: s >> \{$W_1$, \ldots $W_n$\} >> t},
where the destination is $\lambda$,  
$s$ and $t$ are the source and destination router respectively, 
and $W_1, W_2 \ldots W_n \subseteq V$ are waypoint sets.
The configuration $C$ is waypoint-compliant w.r.t $pc$ if: 
\[
\exists \pi \in \paths^C(pc). ~\forall i \leq n. ~\exists w_i \in W_i. 
~\exists u. ~~(u, w_i) \in \pi 
\]
where $\paths^C(pc)$ is the set of induced paths for 
$pc$ (Definition~\ref{def:inducedpaths}). 

In the rest of the section, we discuss the set of constraints
to generate a single logical waypoint policy, and then extend it 
to unordered logical waypoints. Finally, we discuss the synthesis
of resilient configurations which are waypoint-compliant even in 
the face of failures. 

\subsection{Intra-domain Constraints}
Let us consider a waypoint policy for $\lambda$ which
specifies that traffic to $\lambda$ must traverse through
one of the physical waypoints $w \in W$, where $W \subseteq V$.
In the first phase, \genesis provides paths which
satisfy the waypoint policy. We use this path as a 
``hint'' to enforce waypoint-compliance without 
enforcing the exact path. 

We define $D_s^t(W)$ to be the 
distance between $s$ and $t$ such that the path does not
 traverse through any waypoint $w \in W$. Intuitively, we
  can add constraints to represent these distances by
  considering a network topology where all the physical 
  waypoint locations $W$ are removed. Formally, for a topology 
 $T = (V,L)$, the following distance equations 
 capture the non-waypoint distances 
 for a waypoint set $W$:
\begin{equation} \label{eq:wdistance}
\forall s, t \in V \setminus W. ~\forall r \in N(s) \setminus W.~
D_s^t(W) \leq W_s^r + D_r^t(W)
\end{equation}
These constraints are similar to the constraints specified in
\Cref{eq:distance}, but on an ``altered'' topology where all
the waypoint routers are removed, and thus, any path in this 
topology is not compliant with the waypoint policy. 
Similar to $D_s^t$ variables, 
$D_s^t(W)$ is upper bounded by the actual shortest non-waypoint distance from $s$ to $t$.

Given a destination tree $\xi_\lambda$, we will use the non
waypoint distances to enforce waypoint-compliance. Consider a 
router in $r$ such the waypoint $w \in W$ is downstream to $r$ in $\xi_\lambda$
(there exists a path from $r$ to $w$ in $\xi_\lambda$), therefore,
the path from $r$ must traverse through 
a waypoint in $W$.  
Suppose, the sum of weights of the edges of
the path in the tree $W(r \rightarrow^+_{\xi_\lambda} R_\lambda)$  
is strictly smaller than the non-waypoint 
distance from $r$ to $R_\lambda$. This will ensure that 
the shortest path from $r$ to $R_\lambda$ which does not go through
any $w \in W$ will have a distance strictly greater than the path through
$\xi_\lambda$, thus, the path from $r$ to $R_\lambda$ will traverse
through a waypoint $w \in W$. These constraints are expressed as follows:
\begin{equation} \label{eq:waypoint}
\forall r' \in N(s) \setminus N_{\xi_\lambda}(r).~~ \sum_{\mathclap{\substack{l_i=(r_1,r_2)}}} 
W_{r_1}^{r_2} < 
W_{r}^{r'}+ D_{r'}^{R_\lambda}(W) 
\end{equation}
Note that, unlike Equations~\ref{eq:unique}, in this case, 
router $r$ will not necessarily forward traffic to  
$N_{\xi_\lambda}(r)$, but the path chosen will be waypoint-compliant. 
Also, if one of these constraints was part of an unsatisfiable  
core, we can add the static route $(r, N_{\xi_\lambda}(r))$ to
$SR(\lambda)$ to eliminate the equations at router $r$. 

\minisection{Routing Loop Avoidance Constraints} \label{sec:loopavoidance}
Since, we are not enforcing a particular path in the network for waypoint-
compliance, adding
static routes can lead to undesired behaviors like routing loops.  
Consider the example configuration shown in \Cref{fig:ospfexample}(c). 
Traffic for $\lambda$ at router $s$ is forwarded to $r_1$ because of the
static route at $s$. At router $r_1$, the shortest OSPF route to
$\lambda$ is $r_1 \rightarrow s \rightarrow t$ with weight 6 (compared 
to $r_1 \rightarrow t$ of weight 50). Thus, $r_1$ will send the 
packet back to $s$, and thus, causing a routing loop as $s$ will send
it back to $r_1$ and back and forth till the \emph{ttl} (time to live) of the
packet expires. 

Zeppelin adds additional constraints to mitigate the creation of prevention
of routing loops when static routes are added. In each iteration of
Zeppelin's unsat-core learning procedure: 
Zeppelin picks a static route $(r, r')$
for $\lambda$ and removes the constraints pertaining to 
the static route. It also \emph{adds} new constraints to avoid
causing routing loops due to the newly added static route. This
lazy approach ensures we do not add superflous constraints for links
that do not contain a static route in the final configuration 
and will not cause routing loops without sacrificing correctness. 

Suppose, Zeppelin added a static route $(sr_1, sr_2)$ for destination
$\lambda$ where $sr_2 = N_{\xi_\lambda}(sr_1)$ (because we do not add
static routes on any other links except $\xi_\lambda$). We need to
ensure that for any switch in $\xi_\lambda$ which does not 
lie in the downstream path $sr_2 \rightarrow^+_{\xi_\lambda} R_\lambda$, 
the shortest path from $sr_2$ to $R_\lambda$ must not traverse through 
it, for that could potentially cause a routing loop. For example, in \Cref{fig:ospfexample}(c), the shortest path from $r_1$ to $t$ was
going through $s$ (which is upstream of $r_1$), therefore, causing 
a routing loop. 

Therefore, to prevent routing loops, we ensure that the weight
of path $W(sr_2 \rightarrow^+_{\xi_\lambda} R_\lambda)$ is 
strictly smaller than any path from $sr_2$ which traverses a
router $r'$ not in the downstream path from $sr_2$. Zeppelin
adds the following constraints to ensure that the path $l_0...l_k$
from $sr_2$ to $R_\lambda$ is shorter than the paths which reach 
$R_\lambda$ through $r'$: 
\begin{equation}
\forall r' \in \xi_\lambda. ~sr_2 \not\rightarrow_{\xi_\lambda}^+ r'. 
~~~~~\sum_{\mathclap{\substack{l_i=(r_1,r_2)}}} 
W_{r_1}^{r_2} < D^{r'}_{sr_2} + D_{r'}^{R_\lambda} 
\end{equation}
% write about static route for this. 

\subsection{Resilience Synthesis}
