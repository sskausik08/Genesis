\section{Resilient Waypoint-Compliance Synthesis}
A crucial aspect of consideration for tenants is 
policy-compliance under failures (which are frequent in 
datacenter networks), which can violate key security
and availability properties. 
For instance, in 2012,
failure of a router in a Microsoft Azure data center 
triggered previously unknown configuration errors on other 
devices, degrading service 
in the West Europe region for over 2
hours~\cite{azure}; the end goal is 
the synthesis of resilient and policy-compliant 
control planes. 
However, providing compliance 
guarantees for all policies
under arbitary link failures is a difficult problem, 
especially in a traditional control plane 
which reacts to failures in a distributed fashion. 
In \name, we tackle the synthesis of resilient policy-
compliant control planes for a subset of policies: 
\emph{waypoint traversals}.

Middleboxes like firewalls,
proxies, optimizers, and intrusion detection/prevention 
systems 
 play a crucial role in enterprise and
datacenter networks for security, performance,  
and auditing considerations. Support for  
middlebox traversals is commonly 
provided by network operators.
Network Function Virtualization (NFV) has been a 
major driving force for providing reliability 
guarantees under failures  
for middlebox traversals~\cite{opennf, netbricks}. 
Using NFV technology, operators can replicate 
their middleboxes across the network for providing 
resilience guarantees. For waypoint policy-compliance, 
we define a \emph{waypoint set} 
which denotes the set of physical replicas of the 
middlebox; the control plane under a bounded 
number of failures must route traffic through a 
path which traverses an element of the waypoint
set. In the rest of this section, 
we will describe the synthesis of resilient 
waypoint-compliant network configurations. 

\subsection{Problem Statement}
Let us consider an 
unordered waypoint policy of the form: 
\texttt{$\lambda$: s >> $\waypt$ >> t},
where $\lambda$ is the destination IP subnet,  
$s$ and $t$ are the source and destination router respectively, 
and $\waypt \subseteq V$ is the waypoint set. This
policy is mapped to a packet class $pc \in \nat$. 
A configuration $C=(T,\Theta,W,LP,IF,SR)$ is 
\emph{waypoint-compliant} with respect to $pc$ 
iff, there exists a path from $s$ to $t$ in the 
set of induced paths $\paths(pc)$ that traverses
through a waypoint $w \in \waypt$
(Definition~\ref{def:inducedpaths}). 
A configuration $C$ is 
\emph{1-resilient waypoint-compliant} 
for packet class $pc$  
iff,   
$\forall T' = (V, L'), |L'| = |L| - 1$ (single link failures), 
the configuration $C'
=(T',\Theta,W,LP,IF,SR)$  
is waypoint-compliant for packet class $pc$. 

A caveat to note in our definition of waypoint-compliance 
is the use of existential quantifier instead of universal 
quantifier for the set of induced paths for $pc$, i.e.,
the desired routing outcome is the existence of \emph{atleast}
one waypoint-compliant path from $s$ to $t$, 
however, it is possible to
have paths from $s$ to $t$ which are not traversing through 
a waypoint under some failure scenario. Our 
definition can be realized by two mechanisms: 1) A router
which has multiple routes for $\lambda$ will split the traffic
among these routes, and 2) The waypoint can mark certain fields in
the packet header, and the network operator can employ 
simple edge-based checks at the destination 
(for e.g., in the hypervisor) to 
detect if a packet traversed the waypoint or not. Thus, only
packets which traversed a waypoint-compliant path would be 
accepted and forwarded to the tenant. 

\subsection{Intra-domain Resilient Waypoint Compliance}\label{sec:ospfwaypoint}
Let us consider a waypoint policy for $\lambda$ which
specifies that traffic to $\lambda$ from router $s$ 
must traverse through
one of the waypoints $w \in \waypt$. We assume that 
all the waypoints belong in the same domain, i.e., 
$|\{\Theta(w) | w \in W\}| = 1$. NFV provides 
flexibility of waypoint placement in the network, 
and we can ensure
all replicas belong to the same domain.  
Under any single link failure, we need atleast one path 
to $\lambda$ which is waypoint-compliant. 

We leverage \genesis's
support for isolation to generate two edge-disjoint\footnote
{The edge-disjoint paths will actually be vertex-disjoint (except the 
	source and destination) due to the destination-tree constraints
	in \genesis.} paths
which are waypoint-compliant with respect to $\waypt$. A single link
failure will not disable both these paths, so if traffic to $\lambda$ 
would 
traverse one of these two paths under failures, 
we would achieve 1-resilient
waypoint-compliance. However, enforcing the two paths exactly
is difficult. Instead, if we can ensure that the weight
of these two paths is shorter than any non-compliant path in 
the network, $\lambda$ traffic will have atleast two edge-disjoint 
compliant paths to traverse 
before it traverses a non-compliant path. We will now discuss the
constraints to generate a waypoint-compliant path, and then 
how to use the two edge-disjoint paths to provide 1-resilience. 


\subsubsection{Waypoint-Compliance Constraints}
In the first phase, \genesis provides a path which
satisfies the waypoint policy. We use this path as a 
``hint'' to incorporate waypoint-compliance in the OSPF 
configuration synthesis without 
enforcing the exact path.

We define $D_s^t(\waypt)$ to be the 
distance between $s$ and $t$ such that the path does not
 traverse through any waypoint $w \in \waypt$. Intuitively, we
  can add constraints to represent these distances by
  considering a network topology where all the  
  waypoints $w \in \waypt$ are removed. Formally, for a topology 
 $T = (V,L)$, the following distance equations 
 capture the non-waypoint distances 
 for a waypoint set $\waypt$:
\begin{equation} \label{eq:wdistance}
\forall s, t \in V \setminus \waypt. ~\forall r \in N(s) \setminus \waypt.~
D_s^t(\waypt) \leq W_s^r + D_r^t(\waypt)
\end{equation}
These constraints are similar to the constraints specified in
\Cref{eq:distance}, but for an ``altered'' topology where all
the waypoint routers are removed, and thus, any path in this 
topology is not compliant with the waypoint policy. 
Similar to $D_s^t$ variables, 
$D_s^t(\waypt)$ is upper bounded by the actual shortest non-waypoint distance from $s$ to $t$.


Given a destination tree $\xi_\lambda$, we will use the 
non-waypoint distances to enforce waypoint-compliance. Consider a 
router in $r$ such the waypoint $w \in \waypt$ is downstream to $r$ in $\xi_\lambda$
(there exists a path from $r$ to $w$ in $\xi_\lambda$), therefore,
the path from $r$ must traverse through 
a waypoint in $\waypt$.  
Suppose, the sum of weights of the edges of
the path in the tree $W(r \rightarrow^+_{\xi_\lambda} R_\lambda)$  
is strictly smaller than the non-waypoint 
distance from $r$ to $R_\lambda$. This will ensure that 
the shortest path from $r$ to $R_\lambda$ which does not go through
any $w \in \waypt$ will have a distance strictly greater than the path through
$\xi_\lambda$, thus, the path from $r$ to $R_\lambda$ will traverse
through a waypoint $w \in \waypt$. These constraints are expressed as follows:
\begin{equation} \label{eq:waypoint}
\forall r' \in N(s) \setminus N_{\xi_\lambda}(r).~~ \sum_{\mathclap{\substack{l_i=(r_1,r_2)}}} 
W_{r_1}^{r_2} < 
W_{r}^{r'}+ D_{r'}^{R_\lambda}(\waypt) 
\end{equation}
Note that, unlike Equations~\ref{eq:unique}, in this case, 
router $r$ will not necessarily forward traffic to  
$N_{\xi_\lambda}(r)$, but the path chosen will be waypoint-compliant. 
Consider the example in \Cref{fig:ospfw}(a) where traffic for
$\lambda$ must traverse through one of the waypoints $\{r_1, r_2\}$. 
Observe that while \genesis provided the path $s \rightarrow 
r_1 \rightarrow t$, in the solution provided by Zeppelin, 
the shortest path is $s \rightarrow r_2
\rightarrow t$, and both waypoint-compliant paths are shorter 
than $s \rightarrow t$, the shortest non-waypoint path.

If one of these constraints was part of an unsatisfiable  
core, we can add the static route $(r, N_{\xi_\lambda}(r))$ to
$SR(\lambda)$ to eliminate the equations at router $r$. 

\definecolor{orange}{RGB}{255, 157, 30} 
\begin{figure}[!t] 
	\centering
	\subfloat[Edge Weights]{
		\resizebox {0.33\columnwidth} {!} {
			\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
			square/.style={regular polygon,regular polygon sides=4}] 
			\node[state] at (0,0) (s)  {$s$}; 
			\node[state, fill=orange] at (1.8,1) (v1)  {$r_1$}; 
			\node[state, fill=orange] at (1.8,-1) (v2)  {$r_2$}; 
			\node[state] at (3.6, 0)(t) {$t$};
			\node[state, rectangle] at (5, 0) (d1) {$\lambda$};
			\path[->] 
			(s) edge [red] node [black] {1} (v1)
			(s) edge  node {1} (v2)
			edge  node [above] {10} (t)
			(v1) edge [red] node [black] {5} (t)
			(v2) edge  node [black] {1} (t)
			(t) edge [red, dashed] node {} (d1);
			\end{tikzpicture}
		}}
		\hspace*{1cm}
		\subfloat[Routing Loop]{
			\raisebox{0.7cm}{\resizebox {0.33\columnwidth} {!} {
					\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
					square/.style={regular polygon,regular polygon sides=4}] 
					\node[state] at (0,0) (s)  {$s$}; 
					\node[state] at (1.8,1) (v1)  {$r_1$}; 
					\node[state] at (3.6, 0)(t) {$t$};
					\node[state, rectangle] at (5, 0) (d1) {$\lambda$};
					\path[->] 
					(s) edge [red] node [black, sloped, anchor=center, above]
					{$sr(\lambda)$} node
					[black, sloped, anchor=center, below] {1} (v1)
					edge  node [below] {5} (t)
					(v1) edge [red] node [black] {50} (t)
					(t) edge [red, dashed] node {} (d1);
					\end{tikzpicture}
				}}}
				\compactcaption{OSPF edge weights such that the path is waypoint-compliant and example of routing loop created by a static route.}
				\label{fig:ospfw}
			\end{figure}
			
\minisection{Routing Loop Avoidance Constraints} \label{sec:loopavoidance}
Since we are not enforcing a particular path in the network for waypoint-
compliance, adding
static routes can lead to undesired behaviors like routing loops.  
Consider the example configuration shown in \Cref{fig:ospfw}(b). 
Traffic for $\lambda$ at router $s$ is forwarded to $r_1$ because of the
static route at $s$. At router $r_1$, the shortest OSPF route to
$\lambda$ is $r_1 \rightarrow s \rightarrow t$ with weight 6 (compared 
to $r_1 \rightarrow t$ of weight 50). Thus, $r_1$ will send the 
packet back to $s$, and thus, causing a routing loop as $s$ will send
it back to $r_1$ and back and forth till the \emph{ttl} (time to live) of the
packet expires. 

Zeppelin adds additional constraints to mitigate the creation of prevention
of routing loops when static routes are added. In each iteration of
Zeppelin's unsat-core learning procedure: 
Zeppelin picks a static route $(r, r')$
for $\lambda$ and removes the constraints pertaining to 
the static route. It also \emph{adds} new constraints to avoid
causing routing loops due to the newly added static route. This
lazy approach ensures we do not add superflous constraints for links
that do not contain a static route in the final configuration 
and will not cause routing loops. \name does not sacrifice 
soundness by lazily adding the loop avoidance constraints. 

Suppose, Zeppelin added a static route $(sr_1, sr_2)$ for destination
$\lambda$ where $sr_2 = N_{\xi_\lambda}(sr_1)$ (because we do not add
static routes on any other links except $\xi_\lambda$). We need to
ensure that for any router in $\xi_\lambda$ which does not 
lie in the downstream path $sr_2 \rightarrow^+_{\xi_\lambda} R_\lambda$, 
the shortest path from $sr_2$ to $R_\lambda$ must not traverse through 
it, for that could potentially cause a routing loop. For example, in \Cref{fig:ospfexample}(c), the shortest path from $r_1$ to $t$ was
going through $s$ (which is upstream of $r_1$), therefore, causing 
a routing loop. 

Therefore, to prevent routing loops, we ensure that the weight
of path $W(sr_2 \rightarrow^+_{\xi_\lambda} R_\lambda)$ is 
strictly smaller than any path from $sr_2$ which traverses a
router $r'$ not in the downstream path from $sr_2$. Zeppelin
adds the following constraints to ensure that the path $l_0...l_k$
from $sr_2$ to $R_\lambda$ is shorter than the paths which reach 
$R_\lambda$ through $r'$: 
\begin{equation}
\forall r' \in \xi_\lambda. ~sr_2 \not\rightarrow_{\xi_\lambda}^+ r'. 
~~~~~\sum_{\mathclap{\substack{l_i=(r_1,r_2)}}} 
W_{r_1}^{r_2} < D^{r'}_{sr_2} + D_{r'}^{R_\lambda} 
\end{equation}
If one of these constraints is part of an unsatisfiable
core, we need to add a static route to eliminate the 
unsatisfiability. When the constraint is part of the 
unsatisfiable core, it means that there is a routing 
loop caused at $sr_2$. By adding a static route 
$(sr_2, N_{\xi_\lambda}(sr_2))$ to $SR(\lambda)$, we prevent
the occurence of the routing loop from $sr_2$ and thus, can
remove these constraints. After we add the static route,
we add loop avoidance constraints for the new static
route, and continue with the unsat-core learning algorithm. 

\subsubsection{Resilience Constraints} \label{sec:ospfresilience}
For 1-resilience, we use Genesis to provide two waypoint-compliant 
edge-disjoint paths $\pi_1$ amd $\pi_2$ from $s$ to $t$.
Equations~\ref{eq:waypoint} ensure that the edge weights 
of the path provided by Genesis are strictly shorter than 
the non-waypoint distance for $\lambda$. 
Let us assume there are no static routes in the 
OSPF domain. By adding these
constraints for both paths $\pi_1$ and $\pi_2$, 
we enforce a \emph{partial order}: there are two paths to $\lambda$
which are shorter than non waypoint distance, the 
ordering of the weight of $\pi_1$ and $\pi_2$ is irrelevant. 
\begin{equation} \label{eq:resilience}
\{ W(\pi_1), W(\pi_2) \} < D^t_s(\waypt) 
\end{equation}
Thus, if a single link fails, only one 
of these paths is affected. Suppose
$\pi_1$ is affected, OSPF will not route traffic through a  
non-waypoint-compliant path, as the weight of $\pi_2$ is shorter than any path which is not waypoint-compliant due to the constraints generated 
by \name.

\minisection{Resilience with Static Routes}
Suppose there are static routes in the OSPF domain. 
Consider $\pi_1$ and $\pi_2$ are two edge disjoint paths 
connecting the routers $s$ to $t$. Suppose, $\pi_1$ is the 
chosen primary path and it uses static routes on 
some of its links.
Ideally, we want to ensure 
that if any link on $\pi_1$ fails, 
then the network must switch over to $\pi_2$. 
Because of static routes,  
the distance between $s$ and 
$t$ could be different than $W(\pi_1)$ or $W(\pi_2)$.

A static route $(r_1, r_2)$ on path $\pi$ for destination $\lambda$ implies that OSPF routing at $r_1$ is sending traffic to a 
router $r' \not= r_2$ and the OSPF path would be violating
waypoint-compliance. Instead, the static route circumvents 
the OSPF shortest route at $r_1$ and \emph{steers} $\lambda$ 
traffic to $r_2$ and not $r'$. Therefore, for a 
path $\pi$ connecting routers $s$ and $t$ such that it 
has a static route on one of its links, 
then $W(\pi)$ is greater than or equal to the 
actual OSPF distance
between $s$ and $t$ (which is the OSPF route at $s$).
Let us suppose $\pi = l_1 \ldots l_k = (u_1, v_1) \ldots (u_k, v_k)$ 
and 
there exists a $\alpha \leq k$ such that 
$l_\alpha = (u_\alpha, v_\alpha)$  
is the first 
static route from the source in $\pi$, i.e., 
$\forall \beta. ~1 \leq \beta < \alpha. ~(u_\beta, v_\beta) \not\in SR(\lambda)$.
Therefore, all routers between $s$ and $u_\alpha$ did
not require any static routes to steer traffic along a 
non-shortest path. Therefore, we estimate the 
actual shortest OSPF distance between $s$ to $t$ as:
\[
\sum_{i=1}^{\alpha - 1} W_{u_i}^{v_i} + D_{u_\alpha}^t
\]

%\begin{figure}[!t] 
%	\centering
%	\subfloat[Edge Weights]{
%		\resizebox {0.33\columnwidth} {!} {
%			\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
%			square/.style={regular polygon,regular polygon sides=4}] 
%			\node[state] at (-0.6,1.2) (v3)  {$r_3$}; 
%			\node[state] at (1.9,1.2) (v4)  {$r_4$}; 
%			\node[state] at (-2,0) (s)  {$r_0$}; 
%			\node[state] at (-4,0) (src)  {$s$}; 
%			\node[state, fill=orange] at (0.8,0) (v1)  {$r_1$}; 
%			\node[state, fill=orange] at (-0.6,-1.2) (v2)  {$r_2$}; 
%			\node[state] at (3, 0)(t) {$t$};
%			\node[state, rectangle] at (4.4, 0) (d1) {$\lambda$};
%			\path[->] 
%			(s) edge [red] node [black, above] {$sr(\lambda)$} 
%			node [black, below] {4} (v1)
%			(src) edge [red]  node [black, below] {2} (v2)
%			(src) edge [red] node [black] {1} (s)
%			(v3) edge [blue] node [above, black] {1} (s)
%			(v1) edge [blue] node [above, black] {1} (v3)
%			(v1) edge [red] node [black] {1} (t)
%			(v2) edge [red]  node [black, below] {3} (t)
%			(v1) edge node {1} (v4)
%			(v4) edge node {1} (t)
%			(t) edge [red, dashed] node {} (d1);
%			\end{tikzpicture}
%		}}
%				\compactcaption{OSPF edge weights and static routes for 1-resilient waypoint-compliance, where the red paths are the two edge disjoint paths for 
%				$\waypt = \{r_1, r_2\}$. If link $r_1 \rightarrow t$ 
%				fails, }
%				\label{fig:ospfres}
%			\end{figure}


Coming back to the synthesis of resilient configurations,
when \name adds static routes for \emph{steering},  
the partial order \Cref{eq:resilience} is not necessarily true 
(the partial order would hold only under no failures and 
no static routes). 
Because of that, when the primary path $\pi_1$ fails, the 
failover path $\pi_2$ may not be chosen. To ensure that 
$\pi_2$ is always chosen, we try to split the traffic
along $\pi_1$ and $\pi_2$, therefore, a failure to $\pi_1$
will still ensure that traffic is sent through $\pi_2$ 
(which is waypoint-compliant). To enforce splitting amongst
$\pi_1$ and $\pi_2$, we add the following constraints: 
\begin{equation}
	W(\pi_2) \leq \sum_{i=1}^{\alpha - 1} W_{u_i}^{v_i} + D_{u_\alpha}^t	
\end{equation}
where $(u_\alpha, v_\alpha)$ is the first static route in $\pi_1$.
We add symmetric constraints constraining $W(\pi_1)$. 

Similar to the routing loop avoidance constraints, we add the
above constraints lazily when a static route is added to one of the
paths for $\lambda$. However, if one of these constraints is part of 
an unsatisfiable core, we cannot add a static route to eliminate 
this unsatisfiability. \name lazily eliminates these constraints from the
system of equations depending on whether these constraints are part of 
an unsat-core which cannot be eliminated by a static route. Thus, 
our resilience synthesis is not sound and for certain failure scenarios, 
the paths generated are not waypoint-compliant. However, 
based on our experiments (\secref{sec:reseval}), 
this technique generates highly resilient configurations 
in practice. 

