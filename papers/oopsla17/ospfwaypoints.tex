\section{From Waypoint Policies to Policy-Resilient Configurations}

In this section, we consider a setting in which the operator 
wants to 
enforce a restricted set of policies but also wants to guarantee
that, even when a link fails, the resulting configuration is still policy-compliant---i.e.,
the configuration has high policy-resilience.
However, ensuring policy-resilience in the presence of complex and heterogeneous policies,
providing  policy-resiliency is too difficult of a problem.
Therefore, we focus our attention on a restricted but important class of
policies: 
\emph{waypoint traversals}.

Waypoint policies 
that require traffic to traverse
firewalls,
proxies, optimizers, and intrusion detection/prevention 
systems 
play a crucial role in enterprise and
datacenter networks for security, performance,  
and auditing considerations.
Support for  
middlebox traversals is commonly 
provided by network operators.
Network Function Virtualization (NFV) has been a 
major driving force for providing reliability 
guarantees under failures  
for middlebox traversals~\cite{opennf, netbricks}. 
Using NFV technology, operators can replicate 
their middleboxes across the network for providing 
resilience guarantees. 

We therefore focus our attention on policies of the form 
\texttt{$\lambda$: s >> $\waypt$ >> t}
where $\lambda$ is a destination IP subnet,  
$s$ and $t$ are the source and destination router respectively, 
and $\waypt \subseteq V$ is a waypoint set. 
Each policy is mapped to a packet class and
we say that a configuration complies to a policy of this form for the corresponding packet class
$pc$ if
at least one of the induced paths in $\paths^C(pc)$ 
traverses one waypoint $w \in \waypt$.\footnote{
The attentive reader will note that in our definition of waypoint-compliance 
we do not require all induced paths for $pc$ to traverse the waypoints. 
Our 
definition can be realized by two mechanisms: 1) A router
which has multiple routes for $\lambda$ will split the traffic
among these routes, and 2) The waypoint can mark certain fields in
the packet header, and the network operator can employ 
simple edge-based checks at the destination 
(for e.g., in the hypervisor) to 
detect if a packet traversed the waypoint or not. Thus, only
packets which traversed a waypoint-compliant path would be 
accepted and forwarded to the tenant. 
}
Here the set $\waypt$
represents the set of physical replicas of, e.g., a firewall.



%; the control plane under a bounded 
%number of failures must route traffic through a 
%path which traverses an element of the waypoint
%set. In the rest of this section, 
%we will describe the synthesis of resilient 
%waypoint-compliant network configurations. 

 Given a set of such waypoint policies, our goal is to
find a policy-compliant configuration $C=(T,\Theta,W,LP,IF,SR)$ 
with high policy-resilience.

%\emph{1-resilient waypoint-compliant} 
%for packet class $pc$  
%iff,   
%$\forall T' = (V, L'), |L'| = |L| - 1$ (single link failures), 
%the configuration $C'
%=(T',\Theta,W,LP,IF,SR)$  
%is waypoint-compliant for packet class $pc$. 




%A crucial aspect of consideration for tenants is 
%policy-compliance under failures (which are frequent in 
%datacenter networks), which can violate key security
%and availability properties. 


\loris{somewhere describe how it's a two-phase approach
and now all the paper is about 1-resilience so don't say
1 resilience everywhere}



%\subsection{Problem Statement}
%Let us consider an 
%unordered waypoint policy of the form: 
%\texttt{$\lambda$: s >> $\waypt$ >> t},
%where $\lambda$ is the destination IP subnet,  
%$s$ and $t$ are the source and destination router respectively, 
%and $\waypt \subseteq V$ is the waypoint set. This
%policy is mapped to a packet class $pc \in \nat$. 



\subsection{Intra-domain Resilient Waypoint Compliance}\label{sec:ospfwaypoint}
Let us consider a waypoint policy for $\lambda$ which
specifies that traffic to $\lambda$ from router $s$ 
must traverse through
one of the waypoints $w \in \waypt$. We assume that 
all the waypoints belong in the same domain, i.e., 
$|\{\Theta(w) | w \in W\}| = 1$. NFV provides 
flexibility of waypoint placement in the network, 
and we can ensure
all replicas belong to the same domain.  
Under any single link failure, we need atleast one path 
to $\lambda$ which is waypoint-compliant. 

We leverage \genesis's
support for isolation to generate two edge-disjoint\footnote
{The edge-disjoint paths will actually be vertex-disjoint (except the 
	source and destination) due to the destination-tree constraints
	in \genesis.} paths
which are waypoint-compliant with respect to $\waypt$. A single link
failure will not disable both these paths, so if traffic to $\lambda$ 
would 
traverse one of these two paths under failures, 
we would achieve 1-resilient
waypoint-compliance. However, enforcing the two paths exactly
is difficult. Instead, if we can ensure that the weight
of these two paths is shorter than any non-compliant path in 
the network, $\lambda$ traffic will have atleast two edge-disjoint 
compliant paths to traverse 
before it traverses a non-compliant path. We will now discuss the
constraints to generate a waypoint-compliant path, and then 
how to use the two edge-disjoint paths to provide 1-resilience. 


\subsubsection{Waypoint-Compliance Constraints}
In the first phase, \genesis provides a path which
satisfies the waypoint policy. We use this path as a 
``hint'' to incorporate waypoint-compliance in the OSPF 
configuration synthesis without 
enforcing the exact path.

We define $D_s^t(\waypt)$ to be the 
distance between $s$ and $t$ such that the path does not
 traverse through any waypoint $w \in \waypt$. Intuitively, we
  can add constraints to represent these distances by
  considering a network topology where all the  
  waypoints $w \in \waypt$ are removed. Formally, for a topology 
 $T = (V,L)$, the following distance equations 
 capture the non-waypoint distances 
 for a waypoint set $\waypt$:
\begin{equation} \label{eq:wdistance}
\forall s, t \in V \setminus \waypt. ~\forall r \in N(s) \setminus \waypt.~
D_s^t(\waypt) \leq W_s^r + D_r^t(\waypt)
\end{equation}
These constraints are similar to the constraints specified in
\Cref{eq:distance}, but for an ``altered'' topology where all
the waypoint routers are removed, and thus, any path in this 
topology is not compliant with the waypoint policy. 
Similar to $D_s^t$ variables, 
$D_s^t(\waypt)$ is upper bounded by the actual shortest non-waypoint distance from $s$ to $t$.

\definecolor{orange}{RGB}{255, 157, 30} 
\begin{wrapfigure}{Hr}{0.39\columnwidth}
			\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
			square/.style={regular polygon,regular polygon sides=4}] 
			\node[state] at (0,0) (s)  {$s$}; 
			\node[state, fill=orange] at (1.8,1) (v1)  {$r_1$}; 
			\node[state, fill=orange] at (1.8,-1) (v2)  {$r_2$}; 
			\node[state] at (3.6, 0)(t) {$t$};
			\node[state, rectangle] at (5, 0) (d1) {$\lambda$};
			\path[->] 
			(s) edge [red] node [black] {1} (v1)
			(s) edge  node {1} (v2)
			edge  node [above] {10} (t)
			(v1) edge [red] node [black] {5} (t)
			(v2) edge  node [black] {1} (t)
			(t) edge [red, dashed] node {} (d1);
			\end{tikzpicture}
			\compactcaption{OSPF edge weights such that the path is waypoint-compliant.} 
			\label{fig:ospfwayptexample}
\end{wrapfigure}

Given a destination tree $\xi_\lambda$, we will use the 
non-waypoint distances to enforce waypoint-compliance. Consider a 
router in $r$ such the waypoint $w \in \waypt$ is downstream to $r$ in $\xi_\lambda$
(there exists a path from $r$ to $w$ in $\xi_\lambda$), therefore,
the path from $r$ must traverse through 
a waypoint in $\waypt$.  
Suppose, the sum of weights of the edges of
the path in the tree $W(r \rightarrow^+_{\xi_\lambda} R_\lambda)$  
is strictly smaller than the non-waypoint 
distance from $r$ to $R_\lambda$. This will ensure that 
the shortest path from $r$ to $R_\lambda$ which does not go through
any $w \in \waypt$ will have a distance strictly greater than the path through
$\xi_\lambda$, thus, the path from $r$ to $R_\lambda$ will traverse
through a waypoint $w \in \waypt$. These constraints are expressed as follows:
\begin{equation} \label{eq:waypoint}
\forall r' \in N(s) \setminus N_{\xi_\lambda}(r).~~ \sum_{\mathclap{\substack{l_i=(r_1,r_2)}}} 
W_{r_1}^{r_2} < 
W_{r}^{r'}+ D_{r'}^{R_\lambda}(\waypt) 
\end{equation}
Note that, unlike Equations~\ref{eq:unique}, in this case, 
router $r$ will not necessarily forward traffic to  
$N_{\xi_\lambda}(r)$, but the path chosen will be waypoint-compliant. 
Consider the example in \Cref{fig:ospfw}(a) where traffic for
$\lambda$ must traverse through one of the waypoints $\{r_1, r_2\}$. 
Observe that while \genesis provided the path $s \rightarrow 
r_1 \rightarrow t$, in the solution provided by Zeppelin, 
the shortest path is $s \rightarrow r_2
\rightarrow t$, and both waypoint-compliant paths are shorter 
than $s \rightarrow t$, the shortest non-waypoint path.

If one of these constraints was part of an unsatisfiable  
core, we can add the static route $(r, N_{\xi_\lambda}(r))$ to
$SR(\lambda)$ to eliminate the equations at router $r$. 


%\begin{figure}[!t] 
%	\centering
%	\subfloat[Edge Weights]{
%		\resizebox {0.33\columnwidth} {!} {
%			\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
%			square/.style={regular polygon,regular polygon sides=4}] 
%			\node[state] at (0,0) (s)  {$s$}; 
%			\node[state, fill=orange] at (1.8,1) (v1)  {$r_1$}; 
%			\node[state, fill=orange] at (1.8,-1) (v2)  {$r_2$}; 
%			\node[state] at (3.6, 0)(t) {$t$};
%			\node[state, rectangle] at (5, 0) (d1) {$\lambda$};
%			\path[->] 
%			(s) edge [red] node [black] {1} (v1)
%			(s) edge  node {1} (v2)
%			edge  node [above] {10} (t)
%			(v1) edge [red] node [black] {5} (t)
%			(v2) edge  node [black] {1} (t)
%			(t) edge [red, dashed] node {} (d1);
%			\end{tikzpicture}
%		}}
%		\hspace*{1cm}
%		\subfloat[Routing Loop]{
%			\raisebox{0.7cm}{\resizebox {0.33\columnwidth} {!} {
%					\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
%					square/.style={regular polygon,regular polygon sides=4}] 
%					\node[state] at (0,0) (s)  {$s$}; 
%					\node[state] at (1.8,1) (v1)  {$r_1$}; 
%					\node[state] at (3.6, 0)(t) {$t$};
%					\node[state, rectangle] at (5, 0) (d1) {$\lambda$};
%					\path[->] 
%					(s) edge [red] node [black, sloped, anchor=center, above]
%					{$sr(\lambda)$} node
%					[black, sloped, anchor=center, below] {1} (v1)
%					edge  node [below] {5} (t)
%					(v1) edge [red] node [black] {50} (t)
%					(t) edge [red, dashed] node {} (d1);
%					\end{tikzpicture}
%				}}}
%				\label{fig:ospfw}
%			\end{figure}
			
\minisection{Routing Loop Avoidance Constraints} \label{sec:loopavoidance}
Since we are not enforcing a particular path in the network for waypoint-
compliance, adding
static routes can lead to undesired behaviors like routing loops.  
Consider the example configuration shown in \Cref{fig:ospfw}(b). 
Traffic for $\lambda$ at router $s$ is forwarded to $r_1$ because of the
static route at $s$. At router $r_1$, the shortest OSPF route to
$\lambda$ is $r_1 \rightarrow s \rightarrow t$ with weight 6 (compared 
to $r_1 \rightarrow t$ of weight 50). Thus, $r_1$ will send the 
packet back to $s$, and thus, causing a routing loop as $s$ will send
it back to $r_1$ and back and forth till the \emph{ttl} (time to live) of the
packet expires. 

\begin{wrapfigure}{lH}{0.37\columnwidth}
	\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
				square/.style={regular polygon,regular polygon sides=4}] 
				\node[state] at (0,0) (s)  {$s$}; 
				\node[state] at (1.8,1) (v1)  {$r_1$}; 
				\node[state] at (3.6, 0)(t) {$t$};
				\node[state, rectangle] at (5, 0) (d1) {$\lambda$};
				\path[->] 
				(s) edge [red] node [black, sloped, anchor=center, above]
				{$sr(\lambda)$} node
				[black, sloped, anchor=center, below] {1} (v1)
				edge  node [below] {5} (t)
				(v1) edge [red] node [black] {50} (t)
				(t) edge [red, dashed] node {} (d1);
				\end{tikzpicture}
				\compactcaption{Example of routing loop caused by a static route.} \label{fig:ospfloop}
\end{wrapfigure}


Zeppelin adds additional constraints to mitigate the creation of prevention
of routing loops when static routes are added. In each iteration of
Zeppelin's unsat-core learning procedure: 
Zeppelin picks a static route $(r, r')$
for $\lambda$ and removes the constraints pertaining to 
the static route. It also \emph{adds} new constraints to avoid
causing routing loops due to the newly added static route. This
lazy approach ensures we do not add superflous constraints for links
that do not contain a static route in the final configuration 
and will not cause routing loops. \name does not sacrifice 
soundness by lazily adding the loop avoidance constraints. 

Suppose, Zeppelin added a static route $(sr_1, sr_2)$ for destination
$\lambda$ where $sr_2 = N_{\xi_\lambda}(sr_1)$ (because we do not add
static routes on any other links except $\xi_\lambda$). We need to
ensure that for any router in $\xi_\lambda$ which does not 
lie in the downstream path $sr_2 \rightarrow^+_{\xi_\lambda} R_\lambda$, 
the shortest path from $sr_2$ to $R_\lambda$ must not traverse through 
it, for that could potentially cause a routing loop. For example, in \Cref{fig:ospfexample}(c), the shortest path from $r_1$ to $t$ was
going through $s$ (which is upstream of $r_1$), therefore, causing 
a routing loop. 

Therefore, to prevent routing loops, we ensure that the weight
of path $W(sr_2 \rightarrow^+_{\xi_\lambda} R_\lambda)$ is 
strictly smaller than any path from $sr_2$ which traverses a
router $r'$ not in the downstream path from $sr_2$. Zeppelin
adds the following constraints to ensure that the path $l_0...l_k$
from $sr_2$ to $R_\lambda$ is shorter than the paths which reach 
$R_\lambda$ through $r'$: 
\begin{equation}
\forall r' \in \xi_\lambda. ~sr_2 \not\rightarrow_{\xi_\lambda}^+ r'. 
~~~~~\sum_{\mathclap{\substack{l_i=(r_1,r_2)}}} 
W_{r_1}^{r_2} < D^{r'}_{sr_2} + D_{r'}^{R_\lambda} 
\end{equation}
If one of these constraints is part of an unsatisfiable
core, we need to add a static route to eliminate the 
unsatisfiability. When the constraint is part of the 
unsatisfiable core, it means that there is a routing 
loop caused at $sr_2$. By adding a static route 
$(sr_2, N_{\xi_\lambda}(sr_2))$ to $SR(\lambda)$, we prevent
the occurence of the routing loop from $sr_2$ and thus, can
remove these constraints. After we add the static route,
we add loop avoidance constraints for the new static
route, and continue with the unsat-core learning algorithm. 

\subsubsection{Resilience Constraints} \label{sec:ospfresilience}
For 1-resilience, we use Genesis to provide two waypoint-compliant 
edge-disjoint paths $\pi_1$ amd $\pi_2$ from $s$ to $t$.
Equations~\ref{eq:waypoint} ensure that the edge weights 
of the path provided by Genesis are strictly shorter than 
the non-waypoint distance for $\lambda$. 
Let us assume there are no static routes in the 
OSPF domain. By adding these
constraints for both paths $\pi_1$ and $\pi_2$, 
we enforce a \emph{partial order}: there are two paths to $\lambda$
which are shorter than non waypoint distance, the 
ordering of the weight of $\pi_1$ and $\pi_2$ is irrelevant. 
\begin{equation} \label{eq:resilience}
\{ W(\pi_1), W(\pi_2) \} < D^t_s(\waypt) 
\end{equation}
Thus, if a single link fails, only one 
of these paths is affected. Suppose
$\pi_1$ is affected, OSPF will not route traffic through a  
non-waypoint-compliant path, as the weight of $\pi_2$ is shorter than any path which is not waypoint-compliant due to the constraints generated 
by \name.

\minisection{Resilience with Static Routes}
Suppose there are static routes in the OSPF domain. 
Consider the example in \Cref{fig:ospfres} where 
$\pi_1=s\rightarrow r_0 \rightarrow r_1 \rightarrow t$ 
and $\pi_2=s\rightarrow r_2 \rightarrow t$ 
are two edge disjoint paths 
connecting the routers $s$ to $t$. In this example, 
$\pi_1$ is the 
chosen primary path and it use a static routes 
for $r_0 \rightarrow r_1$. 
Ideally, we want to ensure 
that if any link on $\pi_1$ fails, 
then the network must switch over to $\pi_2$. 
When link $r_1 \rightarrow t$ fails,
router $s$ forwards to $r_0$ (
path weight 5: $ s \rightarrow r_0 \rightarrow r_2 \rightarrow t$)
over $r_2$ (path weight 6: $s \rightarrow r_2 \rightarrow t$). 
Because of the static route at $r_0$, traffic is forwarded
to $r_1$ which sends it back to $r_0$ through $r_3$, 
causing a routing loop. Note that, both paths $\pi_1$
and $\pi_2$ have weights smaller than the shortest non-waypoint
 distance, which is $\infty$ for this example, as all paths
 go through $r_1$ or $r_2$. 

\begin{figure}
	\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
	square/.style={regular polygon,regular polygon sides=4}] 
	\node[state] at (-0.6,1.2) (v3)  {$r_3$}; 
	\node[state] at (-2,0) (s)  {$r_0$}; 
	\node[state] at (-4,0) (src)  {$s$}; 
	\node[state, fill=orange] at (0.8,0) (v1)  {$r_1$}; 
	\node[state, fill=orange] at (-0.6,-1.2) (v2)  {$r_2$}; 
	\node[state] at (3, 0)(t) {$t$};
	\node[state, rectangle] at (4.4, 0) (d1) {$\lambda$};
	\path[->] 
	(s) edge [red] node [black, above] {$sr(\lambda)$} 
	node [black, below] {4} (v1)
	(s) edge [black] node {1} (v2)
	(src) edge [red]  node [black, below] {3 (1 $\checkmark$)} (v2)
	(src) edge [red] node [black] {1} (s)
	(v3) edge [blue] node [above, black] {1} (s)
	(v1) edge [blue] node [above, black] {1} (v3)
	(v1) edge [red, strike thru arrow] node [black] {1} (t)
	(v2) edge [red]  node [black, below] {3} (t)
	(t) edge [red, dashed] node {} (d1);
	\end{tikzpicture}
	\compactcaption{Example non-resilient configuration for the red paths provided by Genesis for $\waypt = \{r_1, r_2\}$. If link $r_1 \rightarrow t$ 
		fails, a routing loop is formed at $r_0 \rightarrow r_1 \rightarrow r_3 \rightarrow r_0$, no traffic reaches $t$. 
		The configuration is 1-resilient waypoint-compliant when the $s \rightarrow r_2$ weight is set to 1.}
	\label{fig:ospfresexample}
\end{figure}


When \name adds static routes on the paths, it 
adds loop avoidance constraints assuming no failures. 
However, the static route can lead to a loop under certain
failures. 
Since we impose a partial order on $\pi_1$ and $\pi_2$ (\Cref{eq:resilience}), 
when the primary path $\pi_1$ fails, the 
failover path $\pi_2$ may not be chosen always. 
Instead, we try to split the traffic
along $\pi_1$ and $\pi_2$ even under non-failure scenarios,
therefore, a failure to $\pi_1$
will still ensure that traffic will be 
sent through $\pi_2$. Therefore, we add constraints 
to ensure the following property of splitting 
the traffic among both $\pi_1$ and $\pi_2$. With 
static routes in play, the routes seen at $s$ may not 
correspond to weights $W(\pi_1)$ and  $W(\pi_2)$, thus
the constraint $W(\pi_1) = W(\pi_2)$ does not ensure the 
traffic split (\Cref{fig:ospfresexample}).

A static route $(r_1, r_2)$ on path $\pi$ for destination $\lambda$ implies that OSPF routing at $r_1$ is sending traffic to a 
router $r' \not= r_2$. Instead, the static route circumvents 
the OSPF shortest route at $r_1$ and \emph{steers} $\lambda$ 
traffic to $r_2$ and not $r'$. Therefore, for a 
path $\pi$ connecting routers $s$ and $t$ such that it 
has a static route on one of its links, 
$W(\pi)$ is greater than or equal to the 
actual OSPF distance
between $s$ and $t$ corresponding to $\pi_1$. 
Let us suppose $\pi = l_1 \ldots l_k = (u_1, v_1) \ldots (u_k, v_k)$ 
and 
there exists a $\alpha \leq k$ such that 
$l_\alpha = (u_\alpha, v_\alpha)$  
is the first 
static route from the source in $\pi$, i.e., 
$\forall \beta. ~1 \leq \beta < \alpha. ~(u_\beta, v_\beta) \not\in SR(\lambda)$.
Therefore, all routers between $s$ and $u_\alpha$ did
not require any static routes to steer traffic along a 
non-shortest path. Therefore, our estimate
actual shortest OSPF distance  between $s$ to $t$ 
corresponding to $\pi_1$ 
as the sum of weights till $u_\alpha$ plus the distance
from $u_\alpha$ to $t$. In our running example, 
$u_\alpha = r_0$, the distance between $s$ to $t$ 
is estimated as $W_s^{r_0} + D_{r_0}^t = 1 + (1 + 1 + 1)$
which is the shortest OSPF distance. 

To enforce splitting amongst
$\pi_1$ and $\pi_2$, we ensure that the weight 
of the path $W(\pi_2)$\footnote{
Note that ideally, the OSPF distance corresponding to 
$\pi_2$ would also depend on the first static route on
$\pi_2$, our distance variables are upper bounded by actual
distances and may not be equal, and thus, upper bounding 
those variables in these constraints do not ensure correctness.
For soundness, we use $W(\pi_2)$ which is an upper bound
for the OSPF distance corresponding to 
$\pi_2$. 
} 
is lesser than or equal to 
the estimated OSPF distance corresponding to $\pi_1$: 
\begin{equation}
	W(\pi_2) \leq \sum_{i=1}^{\alpha - 1} W_{u_i}^{v_i} + D_{u_\alpha}^t	
\end{equation}

Similar to the routing loop avoidance constraints, we add the
above constraints lazily when a static route is added to one of the
paths for $\lambda$. However, if one of these constraints is part of 
an unsatisfiable core, we cannot add a static route to eliminate 
this unsatisfiability. \name lazily eliminates these constraints from the
system of equations depending on whether these constraints are part of 
an unsat-core which cannot be eliminated by a static route. Thus, 
our resilience synthesis is not sound and for certain failure scenarios, 
the paths generated are not waypoint-compliant. However, 
judging by our experiments (\secref{sec:reseval}), 
this technique generates highly resilient configurations 
in practice. 
