%!TEX root = paper.tex
\section{From Policies to Connectivity-Resilient Configurations}
\label{sec:config-synthesis}

We now present an algorithm
for synthesizing distributed configurations
that adhere to path policies like the one described 
in Figure~\ref{tab:policysupport}.
In general, no existing tool for synthesizing 
distributed configurations
can handle this heterogeneous set of 
these policies---e.g., isolation---and, even less so,
generate resilient configurations.
Due to the complexity of the problem, we focus on 
synthesizing  configurations that 
are \emph{policy-compliant} and have high \emph{connectivity-resilience}.



\subsection{A two-phase approach}
Existing approaches to configuration synthesis
try to directly generate configurations from the given policies~\cite{synet},
but a direct approach leads to scalability issues as well as limitation
in the set of supported policies.
Instead of directly generating configurations from policies, 
\name uses a two-phase approach:
first it generates policy-compliant paths
and then it synthesizes distributed configurations that realize these paths
and have high connectivity resilience.

For the first phase, we use \genesis~\cite{genesis}, 
a network management system which synthesizes 
SDN forwarding tables enforcing some input policies. 
Some of the policies supported by \genesis are specified in 
\Cref{tab:policysupport}. 
Given a set of policies, \genesis generates a set of constraints 
so that solutions to these constraints are forwarding
tables that can be used to extract the 
policy-compliant paths. 

However, we need to modify the \genesis constraints
to integrate with \name. Legacy protocols only
support destination-based forwarding, unlike OpenFlow switches~\cite{openflow}. 
A router cannot forward a subnet's traffic 
to different routers based on source (or other 
packet headers). Thus, we add additional constraints to ensure
the paths generated by \genesis follow destination-based 
forwarding: paths obtained from 
\genesis for a destination will form a directed tree. 

Let us now look at how we solve the path-compliance problem.
Formally, we are given a set of paths $\Pi$,
a topology $T=(V,L)$,
a domain-assignment function $\Theta$, 
%and configuration policies $P$,
and we want to find functions of the configuration
$C=(\Theta,W,LP,IF,SR)$ such that
$\paths^C(PC) = \Pi$.
%., and
%$C$ satisfies $P$.
%Ideally, we want to directly generate configurations that maximize 
%connectivity resilience, but already generating policy-compliant configuration is
%a hard problem.
In a software-defined OpenFlow~\cite{openflow} network, 
we can program
switch rules to forward traffic 
to a particular next-hop switch. 
Therefore, a trivial solution to the path-compliance problem 
in SDNs is to install forwarding rules along the policy-compliant
paths~\cite{genesis}. Static routes provide the functionality
of specifying the next-hop router,
thus, a solution to the path-compliance problem is to simply
add a static route to $SR(\lambda)$ for every link $l$ in 
set of the paths $\Pi$. Similar to static routes,
Fibbing~\cite{fibbing} used fake 
advertisements to achieve fine-grained control over
OSPF forwarding.


Under no failures, the trivial 
solution of using static routes ensures 
policy-compliance, as traffic follows the paths provided by \genesis. 
However, this solution uses more static routes than necessary
and, in the presence of failures, static routes may
create routing loops that make certain connections 
unreachable, hence reducing connectivity-resilience.
Thus, we set our goal to synthesizing configurations
which are policy-compliant when there are no network 
failures, and improving connectivity-resilience by using
fewer static routes.


% In the following sections, we assume we are given paths that are compliant to 
% all path policies and we only need to find configurations that realize those paths.
% Therefore, the algorithms we present solve the path-compliance synthesis problem
% and whenever we discuss soundness and completeness is with respect to such a problem.
% In general, for a given set of paths, we might not be able to find a path-compliant configuration
% that satisfies all the required configuration policies. However, in this case
% we can simply use ~\genesis to generate a different set of paths.
% Assuming we have a sound and complete algorithm for the
% path-compliance synthesis problem, we can obtain a sound and complete algorithm
% for the
%  configuration synthesis problem by keeping enumerating more policy compliant paths
%  whenever the path-compliance synthesis fails.

We first show how to synthesize 
path-compliant intra-domain 
configurations and then extend to
 inter-domain configurations.



\subsection{Synthesizing Path-compliant Intra-domain Configurations} \label{sec:intra-synthesis}
% To justify the complexity of the techniques 
% we are going to present,
% we show that
% %, even when policy-compliant paths are provided, 
% obtaining configurations with minimal numbers of static routes is a 
% computationally hard problem.

\iffull
\begin{theorem}[Hardness of synthesis]
\label{thm:ospfsynth}
Given a
network with a single domain,
and a positive number $C_{sc}$,
the problem of generating
a path-compliant configuration with at most $C_{sc}$ static routes
is NP-complete.
\end{theorem}
\input{route-filters-nphard}
%\else
%The reduction is from the vertex cover problem.
\fi

In this section, we show how to synthesize 
path-compliant  intra-domain configurations that
use few static routes.
The problem of optimally placing 
static routes is NP-hard (Theorem~\ref{thm:ospfsynth}), 
therefore, we propose a non-optimal greedy strategy.
We first show how to solve the problem when 
there exists a solution with no static routes
and then extend our technique to greedily 
add static routes when needed. We use 
efficient off-the-shelf linear programming 
solvers for solving the system of constraints 
which are presented in the following sections. 
	

\subsubsection{Intra-domain Synthesis without Static Routes} \label{sec:ospf}\hspace*{4mm}


 
In the absence of static routes,
OSPF routers use edge weights to choose the
shortest weighted path for each pair of endpoints. 
The problem of synthesizing the weight function $W$ that
realizes an input set of paths $\Pi$ is a
variation of the so-called {\em inverse shortest path} 
problem~\cite{isp}. 
For a destination IP $\lambda$, we call $\xi_\lambda$ 
the directed tree of $T$ 
obtained by only keeping the nodes and edges 
that are traversed by paths in $\Pi$ for 
$\lambda$; the root of the tree
is the destination router connected to $\lambda$. 
 This destination tree
 property is due to the modifications to \genesis
 to support OSPF's destination-based forwarding. We
 define $\Delta=\{\xi_\lambda\mid \lambda \in \Lambda\}$ to be 
the set of all destination trees. 

Given a set of input paths $\Pi$, \name 
generates a set of linear constraints to 
find weights 
for each directed link in the domain.
The constraints use the variable $W(r_1, r_2)$ and
$D(r_1, r_2)$ to denote the weight 
and shortest distance respectively. 
We add the equation $D(s, s) = 0$.  
\Cref{eq:distance} guarantees that $D(s,t)$ is smaller or equal to
the shortest distance from $s$ to $t$.
\begin{equation} \label{eq:distance}
\forall s, t. ~\forall r \in N(s).~
D(s,t) \leq W(s,r) + D(r,t)
\end{equation}
Intuitively, the shortest path connecting $s$ to $t$
must traverse through one of the neighbor routers of $s$,
and thus, distance can be defined inductively as the 
shortest among distances from the neighbors. 

For each destination tree $\xi_\lambda\in\Delta$, we add equations to ensure 
that the input paths with destination $\lambda$ are the shortest ones.
Notice that, if a path $\pi$
is the shortest path between its endpoints, every 
subpath of $\pi$ also has to be the shortest path between its endpoints.
For each tree $\xi_\lambda$, we define the neighbor
 $N_{\xi_\lambda}(s)$ to denote the 
next-hop neighbor of router $s$ in the destination tree $\xi_\lambda$. 
We denote the router directly connected 
to $\lambda$ (the root of the tree $\xi_\lambda$) by $R_\lambda$.

For a path $\pi$, 
$\sum_{\pi} W$ denotes the sum of weights of all 
links in $\pi$. 
The following equation ensures that, for any node $s$ in 
$\xi_\lambda$, 
the path $(s,r_1)\cdots (r_n,R_\lambda)$ 
in $\xi_\lambda$ is the 
\emph{unique shortest path}:
\begin{equation} \label{eq:unique}
\forall s \in \xi_\lambda. ~
\forall r \in N(s) \setminus N_{\xi_\lambda}(s).~~
\sum_{\mathclap{\substack{(s,r_1)\cdots (r_n,R_\lambda)}}} 
W < W(s,r) + D(r, R_\lambda)
\end{equation}
These constraints guarantee that 
the sum of the weights belonging to the path 
from $s$ to $R_\lambda$ in $\xi_\lambda$ 
is strictly smaller than 
any other path that goes to $R_\lambda$ via 
a node $n'$. Note that,
while $D(r, R_\lambda)$ can be smaller 
than the actual shortest
distance from $r$ to $R_\lambda$, 
$D(r, R_\lambda)$ is used to upper bound the sum of edge weights 
in $\xi_\lambda$, and  
thus, the solution to the edge weights will ensure 
paths in $\xi_\lambda$ are the shortest. 

\minisection{Soundness and Completeness} 
OSPF synthesis is sound---i.e., weights satisfying
constraints (\ref{eq:distance}) and (\ref{eq:unique}) 
will ensure all paths in $\Pi$ are the unique shortest paths. 
OSPF synthesis is complete as well---i.e., if all 
paths in $\Pi$ are the unique OSPF shortest paths, 
the weights will satisfy the constraints. 

\iffull
\begin{theorem}[OSPF Soundness]
%For a OSPF configuration $C$ with edge weights $W$ and no 
%static routes, and for a packet class $pc$, source router $s_{pc}$, destination router $d_{pc}$ and destination $\lambda_{pc}$ and the path provided by Genesis $\pi_{pc}$, if $W$ satisfy constraints \cref{equations}, then $\pi_{pc}$ 
%is in the set of induced paths of $C$, i.e., $~~\pi_{pc} \in \paths^C(pc)$
For a set of paths $\Pi$, if edge weights 
$W$ satisfy constraints (\ref{eq:distance}) and (\ref{eq:unique}), then 
each path $\pi \in \Pi$ is the unique shortest path between its endpoints. 
\end{theorem}
\input{ospf-soundness}
\fi

\iffull
\begin{theorem}[Completeness]
For a set of paths $\Pi$ and edge weights $W$,
if every path $\pi \in \Pi$ is the unique shortest path between its endpoints,
then there exist values for $D$ for which
$W$ satisfies constraints (\ref{eq:distance}) and (\ref{eq:unique}). 
\end{theorem}
\input{ospf-completeness}
\fi


\subsubsection{Intra-domain Synthesis with Static Routes} \label{sec:ospfsr} 
\hspace*{4mm}


\begin{wrapfigure}{r}{0.4\columnwidth}
	\resizebox {0.4\columnwidth} {!} {
			\begin{tikzpicture}[shorten >=0.5pt,node distance=,on grid,auto,
			square/.style={regular polygon,regular polygon sides=4}] 
			\node[state] at (0,0) (s)  {$s$}; 
			\node[state] at (2, 1) (v1)  {$r_1$}; 
			\node[state] at (4, 0)(t) {$t$};
			\node[state, rectangle] at (5.6, 0.75) (d1) {$\lambda_1$};
			\node[state, rectangle] at (5.6, -0.75) (d2) {$\lambda_2$};
			\path[->] 
			(s) edge [red] node [black] {1} (v1)
			edge [blue] node [above, black] {5} node [below, black] {$SR(\lambda_2)$} (t)
			(v1) edge [red] node [black] {2} (t)
			(t) edge [red, dashed] node {} (d1)
			(t) edge [blue, dashed] node {} (d2);
			\end{tikzpicture}
	}
	\caption{Example illustrating the use of static routes.}
	\label{fig:srexample}
\end{wrapfigure}

If the system of equations presented in Section~\ref{sec:ospf} admits a solution, 
the values of the $W(s,t)$ variables are the weights we are trying to synthesize,
otherwise the intra-domain synthesis problem 
cannot be solved without static routes.
Consider the paths in \Cref{fig:srexample} 
between $s$ and $t$ for  
$\lambda_1$ and $\lambda_2$. 
There exists no solution as 
the following is required for $\lambda_1$: 
$W(s \rightarrow r_1 \rightarrow t) < W(s \rightarrow t)$, 
and vice-versa for $\lambda_2$. 
To steer the traffic for a particular destination
to a next-hop router not on the shortest path, we  
install a static route. 
%Since there are no static routes for
%$\lambda_1$, the traffic to $\lambda_1$ will be forwarded to $t$
%through $r_1$ using the OSPF shortest path.



Since the problem of minimizing the number of static routes
is NP-hard, we opt to place static routes using a best-effort approach.
Our algorithm starts by trying to synthesize a solution
that does not use static routes using the equations 
proposed in \secref{sec:ospf}. 
In the case of a failure, the algorithm uses the ``proof of unsatisfiability''---i.e., the unsatisfiable core---generated by 
the constraint solver 
to greedily add a small set of static routes. 
Certain equations are eliminated 
to model the added static routes 
and the approach is repeated until a solution is found.
%We now propose a
%technique for choosing the static routes based 
%on the unsatisfiable core. 

%\kausik{Equations with static routes:
%%\loris{why do we need to modify \eqref{eq:dist}? Can't we just add $D_s^t(d)\geq D_s^t$ for
%%all $d$}
%We assume we are given a route-filter function $RF$ and 
%use $s\rightarrow_d^* t$ to denote that $s$ can reach $t$
%without using any edge in $RF(d)$.
%We use the variable $D_{r_1}^{r_2}(d)$ to denote the shortest distance from $r_1$ to $r_2$
%using only edges that are not filtered for destination $d$.
%We can revise equation \eqref{eq:dist}   to restrict the values of 
%each variable $D_{r_1}^{r_2}(d)$
%by  ignoring all the filtered edges---i.e., only consider a switch $r\in N(s)$ if
%$(s,r)$ is not in $RF(d)$. 
%In summary, we need to add one modified version of equation \eqref{eq:dist} 
%and equation  \eqref{eq:unique} for each destination $d$.
%If the encoding without route filters produces $n$ equations, this
%encoding produces $kn$ equations where $k$ is the total number of destinations.  
%To mitigate this problem, we observe that the shortest distance $D_s^t(d)$ between two
%nodes $s$ and $t$ without using edges filtered for $d$ is
%greater or equal to the distance $D_s^t$ obtained without route filters.  
%We use this property to simplify the
%encoding by only computing $D_s^t$ and by replacing each instance of
%$D_s^t(d)$ with $D_s^t$ in the equations.  It is easy to see that 
%if the set of constraints with variables $D_s^t(d)$ admits a solution,
%the corresponding set of constraints with variables $D_s^t$ 
%also admits a solution (because $D_s^t\leq
%D_s^t(d)$).  However, the reverse is not true and the set of
%simplified equations can be unsatisfiable in cases in which the
%original set is satisfiable, causing addition of unnecessary filters.
%Since our algorithm is already greedy and it does not try to compute the optimal 
%number of route filters, this is not a problem.}

\iffull
\begin{figure}
	\centering
	\vspace{-7mm}
	\begin{minipage}{0.7\columnwidth}
		\begin{algorithm}[H]
			\begin{footnotesize} 
				\caption{OSPF-SR Synthesis}
				\label{alg:unsat}
				\begin{algorithmic}[1]
					\Procedure{OSPF_SYNTH}{$\Pi$} 
					\State{$\Psi_D:$ Distance constraints (\ref{eq:distance})}
					\State{$\Psi_S:$ Shortest path constraints generated for $\Pi$ 
						(\ref{eq:unique}) \label{line:unique} }
					\State{$\Psi = \Psi_D \cup \Psi_S$} 
					\While{$\Psi$ is \emph{unsat}} 
					\State{Extract unsat core $uc$ from LP Solver}
					\State{Pick random static route $sr(s, t, \lambda)$ from $uc$}
					\State{Add $sr$ to static routes $SR$ \label{line:staticroute}}
					\State{$\Psi = \Psi \setminus \Psi_S(s, \lambda)$ \label{line:removeconstraint}}
					\EndWhile
					\State{Obtain $W$ from solution model of $\Psi$}
					\Return{Configuration $C(W,SR)$} 
					\EndProcedure
				\end{algorithmic}
			\end{footnotesize}
		\end{algorithm}
	\end{minipage}
\end{figure}
\fi

%\minisection{Adding static routes using unsatisfiable cores}
Intuitively, an unsat core or IIS (Irreducible Inconsistent Subsystem)~\cite{chinneck2007feasibility} 
is a subset of the input constraints such that,
if all constraints except those in the IIS are removed, the resulting set of
linear equations is still unsatisfiable. 
Moreover, the set is irreducible---i.e., removing 
any one constraint from the IIS produces a satisfiable set of constraints. 
In our case, an IIS cannot consist of only 
constraints from \Cref{eq:distance} as these constraints
admit a trivial solution with all variables set to 0. 
Therefore, an IIS must contain some constraint of the form
given in Equations~(\ref{eq:unique}). Let us denote 
this set of constraints as $\Psi_S(s, \lambda)$:
\[
[\sum_{\mathclap{\substack{l_i=(r_1,r_2)}}} 
W(r_1, r_2) < W(s, r) + D(r, R_\lambda) ] \in \Psi_S(s, \lambda)
\]	
This constraint is added to ensure 
that router $s$ forwards to traffic to next-hop
$N_{\xi_\lambda}(s)$ and not some neighbor router 
$r$, based on OSPF weights,
but the path through $r$ is causing the unsatisfiability. 
To remove this inequality from the set of constraints, 
we add the static route $(s,N_{\xi_\lambda}(s))$ to $SR(\lambda)$.
As a result of adding a static route, \name removes 
the $\Psi_S(s, \lambda)$ constraints as router $s$ 
will forward $\lambda$ traffic  to 
next-hop $N_{\xi_\lambda}(s)$ irrespective of
the OSPF distances to the destination; the 
unsatisfiability caused by this IIS is eliminated. 
However, the new set of
constraints may still be unsatisfiable due to other IISes.
We repeat the procedure and add static routes
until we obtain a satisfiable set of
constraints. 
In each iteration, there can be more than one way to place a static route and
\name picks one randomly. 

\iffull
\begin{theorem}[OSPF+SR Soundness] \label{thm:ospfsr}
	Given a set of packet classes $PC$ and paths $\Pi$, \Cref{alg:unsat} outputs
	a configuration $C(W,SR)$ such that $\Pi\subseteq\paths^C(PC)$.
\end{theorem}
\input{ospfproofs}
\fi

\minisection{Soundness and Completeness}
OSPF synthesis with static routes 
is sound---i.e, the configuration $C(W,SR)$ 
will induce the paths $\Pi$ provided by \genesis. As far as
completeness goes, \name is guaranteed to find a solution if
there are no constraints on the number of static routes (use
static routes along each path). If there is a configuration policy 
upper bounding the number of static routes, the synthesis procedure 
is not guaranteed 
to find a compliant configuration, if one exists. 
Since there can only be finitely many 
solutions for paths and possible SR assignments, we are eventually guaranteed 
to find a solution by repeating \genesis and
OSPF-SR synthesis multiple times and choosing different
solutions.


% For any input $(PC, \Pi)$, there is a trivial configuration that uses static
% routes along each path to guarantee that  
% $\Pi\subseteq\paths^C(PC)$. Therefore, without constraints on the
% number of static routes, \name is guaranteed to find a solution.
% However, if there is a configuration policy 
% upper bounding the number of static routes, \Cref{alg:unsat} is not guaranteed 
% to find a compliant configurations, if one exists. 
% Completeness is recovered by running \Cref{alg:unsat} multiple times and choosing different
% unsatisfiable cores and static routes assignments. Since there can only be finitely many
% possible assignments, we are eventually 
% guaranteed to find a solution if one exists for the input $(PC, \Pi)$.