\section{Introduction}
%% Conventionally, a network primarily acted as a backbone for
%% communication among machines, and these communications used the
%% ``shortest" path in the network based on certain metrics for deciding
%% the path between two machines.  Today,

Many enterprises are increasingly migrating their on-premise IT
infrastructure to cloud datacenters. In such environments, the
different enterprises (tenants) share different resources, such as,
the compute machines that run their applications and network
infrastructure used for communication among these applications.
Operators of such multi-tenant datacenters thus have to deal with a
multitude of machines communicating with each other (flows) over a
network that is composed of many tens to hundreds of routers or
switches (devices)~\cite{mpa-imc15}. With growing diversity of
enterprise applications and the need for security and compliance,
these pathways of communication through the datacenter network are
subject to increasingly complex network-based policies.

Consider a tenant in such a datacenter. She may desire
basic communication among her applications (reachability) along
shortest paths based on certain metrics. In addition, she may wish
that traffic attempting to reach some of her applications is examined
by a set of ``middleboxes'' (traversal) for auditing and access control. 
For strong security or Quality-of-Service considerations,
a tenant may additionally desire that a subset of her
flows does not share any infrastructure with others' flows (isolation).  
In parallel,
cloud operators must meet key operational policies. For instance, they
often need to optimize network performance objectives (traffic
engineering), e.g., minimizing the maximum load imposed by all tenants
on network links, and deal with resource constraints such as link
capacity bounds and switch table sizes. Also, since datacenter
networks are highly prone to link/switch
failures~\cite{datacenterfailures}, operators need to gracefully
transition the old (pre-failure) data plane to a policy-compliant one
(post-failure) in a rapid and/or efficient manner.

Today, configuring network devices to enforce these complex policies
in aggregate is manual, ad-hoc, and error-prone.  This
can lead to misconfigurations and violations of tenant service-level
agreements, which can have severe performance and security
impacts.

%%  However, in real-life, the
%% process of policy enforcement by network operators is manual and
%% ad-hoc, leading to violations of service-level agreements and
%% mis-configurations which have severe performance and security
%% impacts. With the boom in cloud services, datacenter networks deal
%% with thousands of flows which are not constant, but in flux, thus,
%% making it difficult to enforce them in an ad-hoc manner.

%% Network operators desire various different end-to-end policies to
%% support in clouds and enterprise networks. Tenants or organisations
%% require support for basic policies like reachability between hosts,
%% and specifying different middlebox policies for certain
%% flows. Operators, on top of that require support for complex policies
%% like traffic isolation between flows to provide fairness and
%% specifying resource constraints like link bandwidth and switch table
%% sizes to perform traffic engineering and network resource management.

With software-defined networking (SDN),
operators can program networks in a more intuitive manner. In SDN, a
general-purpose centralized controller machine (control plane)
controls end-to-end communication pathways by managing network
forwarding rules on a collection of programmable switches (data
plane). Using a global view of the current network topology, the
controller can program forwarding rules on switches based on
application requirements.
%However, many existing SDN
%frameworks are too low-level, 
%making it challenging 
%to write controller applications using these which generate 
% the data plane enforcing the above policies. %% For many
%% of the policies, generating the data plane is an NP-complete problem
%% and requires the design of efficient custom heuristics; combining
%% different policies' heuristics together is non-trivial.
Unfortunately, many existing SDN programming languages 
~\cite{frenetic,pyretic} present too
narrow a view: operators would ideally want to specify and realize
policies network-wide, whereas these languages focus on
programming {\em individual} switch behaviors.  While the 
NetKAT language~\cite{netkat, netkatcompiler} is more expressive and
can be used to encode certain network-wide policies like regular paths and 
programs on virtual topologies, we cannot express policies 
like isolated paths or traffic engineering using NetKAT. For many
types of policies, generating a data plane that enforces them is a
%  an NP-complete 
computationally hard problem, requiring the design of efficient custom
heuristics per policy type. Other recent works on
network-wide policy enforcement~\cite{merlin,simple, fattire} go beyond the
single-switch model, but they target specific types of policies and
thus are difficult to extend to other commonly desired policy types
(e.g., isolation).
%; combining  different policies' heuristics together is non-trivial. 
 %% \aditya{we need to be
% careful
%%   not to bin all SDN languages into this switch-by-switch model}
%% \kausik{Do you want to make changes here?}







%% support
%% other kinds of policies such as traffic isolation.

%%  like
%% joint bandwidth provisioning and waypoint routing in Merlin
%% \cite{merlin}, and middlebox policy enforcement in SIMPLE
%% \cite{simple} or FlowTags~\cite{flowtags}. However, these approaches

In this paper, we seek a general approach that allows a variety
of rich policies to be specified as the input, with the output being
the corresponding set of switch forwarding rules such that the
complexities of correctly realizing the policies in the data plane are
hidden from operators. This is an important step toward {\em
  intent-based networking}~\cite{intent}, where operators specify {\em
  what} they want the network to do instead of worrying about {\em
  how} the network must be configured.
%their networks. %% To support a cornucopia of policies, an
%% important feature is \emph{generality} of the approach of policy
%% enforcement, so that it can be extended to enforce custom policies
%% required by the operator.
We argue that data plane synthesis can help 
realize this vision in the multi-tenant datacenter
context.
%% switch
%% table forwarding rules to the solve the problem of policy enforcement
%% by use of off-the-shelf SMT-solvers.

We present \Name, a framework for declaratively specifying and
enforcing complex policies such as, isolation, middlebox traversals,
network optimization objectives, and failure resilience. To tackle the
high complexity of enforcing some of these policies (e.g.,
enforcing isolation is NP-complete), \Name encodes the problem
of enforcing policies as a constraint solving problem 
and leverages recent advances in fast
Satisfiability Modulo Theories (SMT) solvers to efficiently search for
a solution to the constraints. The solution is then translated into
switch forwarding rules. \Name uses two intuitive relations that
concisely capture the semantics of custom network forwarding
behaviors. These help express a variety of both path-based and global
policies desired in a datacenter. Interestingly, complex global policies (specifically,
policy-compliant failure resilience) can be realized within this
framework without requiring additional encoding (of specific failure
scenarios) by just cleverly transforming path-based policies.
%Using SMT solvers with 
%support for linear optimization, \name can perform traffic engineering, and
%minimal network repair. We extend \name to synthesize
%resilient switch tables to \emph{proactively} ensure policy-compliance
%in failure scenarios. 
%% This
%% paper presents Genesis, a
%% network management tool where the network operators can express the
%% network-wide policies in a high-level declarative manner and Genesis
%% will synthesize the lower-level switch forwarding rules for realising
%% these policies, eliminating the need for operators to work on
%% switch-level behaviours. 
By leveraging the formal guarantees of constraint solving, \Name
eliminates the room for error in the enforcement of complex
policies.

%\kausik{Do we need to make the point of sacrificing performance for generality for POPL? }

%% Due to the the large space of forwarding plane configurations, naively
%% encoding policies using SMT solvers results in slow synthesis (several
%% minutes in the median case; \secref{sec:baselineeval}).
%enterprise networks today because the space of forwarding plane configurations
%is huge. 
Further, we present two novel techniques that leverage domain-specific properties to speed up \Name's synthesis.
%% We argue that synthesis can be significantly sped up by leveraging  domain-specific
%% properties to simplify the constraints handled by the SMT solver.
First, \Name
allows the network operator to write restricted forms of regular
expressions, called \emph{tactics}, that blacklist paths based on
certain patterns that are not desired in a datacenter network (e.g.,
paths that alternate between topology tiers).
%\loris{how about: ...based on path patterns that are not desired...}
These tactics are used to discard several constraints, 
acting as a search strategy for the solver.
%\aditya{the previous sentence is vague}
%By identifying a restricted syntax for specifying
%tactics, we 
Tactics can speed up the synthesis procedure by
%constraints added to the solver without additional constraints
%required to ensure the solution satisfies the tactic and achieve
$1.5-400\times$ (median speedup: 1.6$\times$, average speedup:
22$\times$).
 Second, we develop a \emph{divide-and-conquer} synthesis procedure
 that opportunistically leverages the dependency relationships among
 isolation policies to improve synthesis performance. The procedure
 partitions the input policies into components such that
 \name can synthesize these components separately and faster than the
 complete problem.  Divide-and-conquer synthesis can halve the
 synthesis time for 40\% of synthetic isolation workloads.
 %% which vary in size and complexity
 %% of isolation.
 %\aditya{is this statement correct? what is 40\% of scenarios?}
 %\aditya{the
   %previous sentence is vague} 

%% are
%% huge, and by supporting a set of diverse and complex policies with
%% different search objectives, we require to create a model general and
%% expressive enough to support these. This poses a challenge as to can
%% synthesis performance be improved by leveraging knowledge specific to
%% the problem of policy enforcement in networks?

%We implement \Name using ... We evaluate it using .... Key highlights .... \aditya{all of these are todo}.\kausik{Do we need a para or will the next para suffice?}
\noindent \textbf{Contributions.} \ \ \ Our contributions are the following.
\begin{compactitemize}
\item An extensible declarative framework for describing
  complex policies and a modular SMT-based algorithm for enforcing policies 
  like isolation, waypoints (\secref{sec:synthesisalgo}), traffic engineering~(\secref{sec:optimization}), and 
  failure resiliency (\secref{sec:resiliency});
\item A modified synthesis algorithm based on tactics, which leverages datacenter network structure
  to blacklist undesirable path patterns (\secref{sec:tactic});
\item A divide-and-conquer procedure for speeding up synthesis by leveraging the 
structure of policy interactions (\secref{sec:optimistic});
\item An implementation of \Name and an extensive evaluation on
  different policy workloads, topologies and multi-tenancy
  settings (\secref{sec:evaluation}).
		%to quantify the performance of Genesis. 
\end{compactitemize}
%\aditya{todo}

\iffull\else
A long version
of this paper containing all the proofs has been submitted as supplementary material.
\fi
%% : We present the design and implementation of a network management
%% system with support for a diverse set of complex end-to-end
%% policies like isolation, waypoints and capacity. We designed a
%% novel search strategy using regular expressions to prune the space
%% of forwarding plane configurations by leveraging the network
%% structure to provide properties of the path, especially in
%% datacenter topologies. Lastly, we design a heuristical synthesis
%% routine leveraging the nature of policy interactions to improve
%% synthesis performance.
